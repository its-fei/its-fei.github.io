<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>prometheus + grafana 监测ceph集群状态</title>
      <link href="/2024/05/22/prometheus-grafana-%E7%9B%91%E6%B5%8Bceph%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81/"/>
      <url>/2024/05/22/prometheus-grafana-%E7%9B%91%E6%B5%8Bceph%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h5 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h5><p>最近在使用海量小文件压测ceph集群，<strong>想要一个可视化的界面来方便监测ceph集群状态</strong>，由于很久之前使用过prometheus + grafana 监测 k8s 集群状态，想着用来监测 ceph 集群应该问题不大，那么就开始吧！</p><p>首先了解下 <strong>prometheus 和 grafana 是什么</strong>？<br>通俗来讲，<strong>Prometheus可以通过各种方式采集应用程序和系统的指标数据</strong>，例如服务器的 CPU 使用率、内存使用率、网络流量等等。采集到的数据会存储在一个时间序列数据库中，用户可以使用PromQL查询语言进行查询和分析。同时，Prometheus还提供了告警机制，可以在监控数据超出设定的阈值时发出告警通知。而<strong>Grafana可以通过连接Prometheus数据源，将采集到的数据进行可视化展示</strong>，例如将 CPU 使用率和内存使用率用折线图的形式展示出来。用户可以通过配置仪表盘来自定义展示的数据和样式，以及添加告警规则和面板等。</p><p><strong>Prometheus + Grafana组合就是一套监控和可视化解决方案，可以帮助用户更好地监控和管理他们的应用程序、服务器和网络设备。</strong></p><p>在 Ceph Luminous (12.x) 之前的版本，可以使用第三方的 ceph_exporter 采集 Ceph 集群的监控信息。 从 Ceph Luminous 12.2.1 版本开始，MGR 中自带了 Prometheus 插件，内置了 Prometheus Ceph Exporter，可以使用 Ceph MGR 内置的 exporter 作为 Prometheus 的 target。</p><h4 id="一、启用-ceph-prometheus-模块"><a href="#一、启用-ceph-prometheus-模块" class="headerlink" title="一、启用 ceph prometheus 模块"></a>一、启用 ceph prometheus 模块</h4><p>任意一台ceph mgr节点执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph mgr module enable prometheus</span><br></pre></td></tr></table></figure><p>启用成功后可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# ceph mgr services</span><br><span class="line">&#123;</span><br><span class="line">    &quot;dashboard&quot;: &quot;https://node1:8443/&quot;,</span><br><span class="line">    &quot;prometheus&quot;: &quot;http://node1:9283/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 9283 是 ceph_exporter 的默认监听端口，访问 <code>http://&lt;MGR&gt;:9283/metrics</code> 可以获取到 metrics</p><p><img src="/../images/ui_1.png" alt="prometheus"></p><h4 id="二、安装-prometheus-server"><a href="#二、安装-prometheus-server" class="headerlink" title="二、安装 prometheus server"></a>二、安装 prometheus server</h4><h5 id="1、二进制安装"><a href="#1、二进制安装" class="headerlink" title="1、二进制安装"></a>1、二进制安装</h5><p>Prometheus 基于 Golang 编写，编译后的软件包，不依赖于任何的第三方依赖。所以只需要下载对应平台的二进制包，解压并且添加基本的配置即可正常启动 Prometheus Server。</p><p>下载地址：<a href="https://prometheus.io/download/">https://prometheus.io/download/</a></p><p>解压并且移动到 &#x2F;opt&#x2F; 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# tar zxvf prometheus-2.45.0.linux-amd64.tar.gz</span><br><span class="line">[root@node1 ~]# mv prometheus-2.45.0.linux-amd64 /opt/prometheus/</span><br><span class="line">[root@node1 ~]# cd /opt/prometheus/</span><br></pre></td></tr></table></figure><h5 id="2、将-prometheus-配置为系统服务进行管理"><a href="#2、将-prometheus-配置为系统服务进行管理" class="headerlink" title="2、将 prometheus 配置为系统服务进行管理"></a>2、将 prometheus 配置为系统服务进行管理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/prometheus.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=prometheus</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/prometheus/prometheus --config.file=/opt/prometheus/prometheus.yml --storage.tsdb.path=/opt/prometheus/data/ --web.enable-lifecycle</span><br><span class="line">ExecReload=/bin/kill -HUP \$MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h5 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start prometheus</span><br><span class="line">systemctl enable prometheus</span><br></pre></td></tr></table></figure><p>出现关键信息<code>Server is ready to receive web requests.</code> 则启动成功，此时可以通过 <code>http://&lt;IP&gt;:9090</code> 访问 Prometheus 的 UI 界面</p><p><img src="/../images/ui_2.png" alt="image"></p><h5 id="4、配置-prometheus-数据源"><a href="#4、配置-prometheus-数据源" class="headerlink" title="4、配置 prometheus 数据源"></a>4、配置 prometheus 数据源</h5><p>为了让 Prometheus Server 能够从 Ceph Exporter 获取到监控数据，需要修改 Prometheus 配置文件。编辑 prometheus.yml 并在 scrape_configs 节点下添加以下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# vim /opt/prometheus/prometheus.yml</span><br><span class="line">...</span><br><span class="line">  - job_name: &quot;Ceph&quot;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;&lt;IP&gt;:9283&quot;]</span><br></pre></td></tr></table></figure><p>重新加载 <code>systemctl reload prometheus</code>,再次访问 <code>http://&lt;IP&gt;:9090</code>，选择<code>Status -&gt; Targets</code>，此时可以成功获取到 prometheus 数据源</p><p><img src="/../images/ui_3.png" alt="image"></p><h4 id="三、安装-grafana"><a href="#三、安装-grafana" class="headerlink" title="三、安装 grafana"></a>三、安装 grafana</h4><h5 id="1、二进制安装-1"><a href="#1、二进制安装-1" class="headerlink" title="1、二进制安装"></a>1、二进制安装</h5><p>下载地址：<a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# tar zxvf grafana-enterprise-8.0.5.linux-amd64.tar.gz</span><br><span class="line">[root@node1 ~]# mv grafana-8.0.5/ /opt/grafana/</span><br><span class="line">[root@node1 ~]# cd /opt/grafana/</span><br></pre></td></tr></table></figure><h4 id="2、将-grafana-配置为系统服务进行管理"><a href="#2、将-grafana-配置为系统服务进行管理" class="headerlink" title="2、将 grafana 配置为系统服务进行管理"></a>2、将 grafana 配置为系统服务进行管理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/grafana.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=grafana</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/grafana/bin/grafana-server -homepath=/opt/grafana</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h5 id="3、启动-grafana-服务"><a href="#3、启动-grafana-服务" class="headerlink" title="3、启动 grafana 服务"></a>3、启动 grafana 服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start grafana</span><br><span class="line">systemctl enable grafana</span><br></pre></td></tr></table></figure><p>启动成功后可通过<code>http://&lt;IP&gt;:3000</code> 进入到 Grafana UI，默认情况下使用账户 admin&#x2F;admin 进行登录（首次登录会要求修改默认密码）。点击 “Add your first data source” 添加数据源</p><p><img src="/../images/ui_4.png" alt="image"></p><p>选择 “Prometheus”，点击右侧的 “Select”</p><p><img src="/../images/ui_5.png" alt="image"></p><p>“URL” 填写 Prometheus 的访问地址，滑到最下方点击 “Save &amp; test” 完成添加，配置正确的情况下会提示 “Data source is working” 的信息。</p><p>完成数据源的添加之后就可以在 Grafana 中创建可视化 Dashboard 了，选择左侧 <code>Dashboards -&gt; Manage</code>，点击 <code>Import</code>,输入 Dashboard 模板编号 2842，点击 <code>Load</code>,给 Dashboard 配置个名称，选择数据源为 <code>Prometheus</code>，最后点击 <code>Import</code></p><p><img src="/../images/ui_6.png" alt="image"></p><h4 id="部署中遇到的几个小问题："><a href="#部署中遇到的几个小问题：" class="headerlink" title="部署中遇到的几个小问题："></a>部署中遇到的几个小问题：</h4><p>1、由于服务器是局域网，时间服务器设置问题，导致 prometheus 对接数据源的时候会有警告<code>Warning: Error fetching server time: Detected 229.88299989700317 seconds time difference between your browser and the server. Prometheus relies on accurate time and time drift might cause unexpected query results.</code></p><p>先选择了笨办法手动改一下时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2023-06-28 11:41:00&quot;</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><p>2、添加 dashboard 模板时，输入模板编号提示<code>Bad Gateway</code>,此时可以去<a href="https://grafana.com/grafana/dashboards/">grafana dashboards官网</a>自行下载json文件然后<code>Upload JSON file</code><br><img src="/../images/ui_7.png" alt="image"></p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>文章主要参考自 <a href="https://www.koenli.com/af5b9d4e.html">使用 Prometheus+Grafana 监控 Ceph</a>，在此基础上根据自身环境所撰写，如有侵权请联系删除！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络流量问题排查-UDP丢包</title>
      <link href="/2024/05/22/Linux%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-UDP%E4%B8%A2%E5%8C%85/"/>
      <url>/2024/05/22/Linux%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-UDP%E4%B8%A2%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><em>一直以来对Linux网络这部分了解比较少，解决问题总是没有条理</em></p><p><strong>问题：</strong>遇到一个<strong>UDP丢包</strong>的问题：在测试中，一台VM虚拟机，CPU利用率55%左右，内存利用率7%左右，网卡流量也远没到限制的时候出现了丢包情况**</p><p><strong>验证：</strong><code>netstat -su|grep &quot;packet receive errors&quot;|awk &#39;&#123;print $1&#125;&#39;</code>  ，每30s查看一次，计算这次和上次之间的数值差值发现存在UDP丢包现象。</p><p>首先要看问题出现在哪儿，网络流量的路径是怎样的？</p><blockquote><p>1、网络流量通过有线&#x2F;无线发送到网卡<br>2、网卡驱动读取报文放到ring buffer（此时调用DMA，不经过CPU）<br>3、内核从ring buffer中读取报文进行处理，执行IP层，TCP&#x2F;UDP层逻辑<br>4、把报文发到用户态的socket buffer中，应用程序读取socket buffer并进行处理</p></blockquote><p>可能出现问题的地方：1、网卡处理时丢包   2、内核处理时丢包   3、应用程序处理时</p><blockquote><p>1、网卡阶段：</p></blockquote><p>两种方法：</p><p>(1).  <code>ifconfig</code> 查看 <strong>RX errors dropped</strong></p><p>(2).  <code>ethtool -S eth0 |egrep &quot;err|drop&quot;</code></p><p>如果存在丢包，可以查看网卡的ring buffer size是否设置太小达到瓶颈，使用<code>ethtool -g eth0</code>查看最大值和当前值，使用<code>ethtool -G eth0 rx 1024</code>进行修改</p><p>如果网卡方面没问题，那么尝试内核方面查看</p><blockquote><p>2、内核阶段</p></blockquote><p>linux 系统在接收报文之后，会把报文保存到缓存区中。因为缓存区的大小是有限的，如果出现 UDP 报文过大(超过缓存区大小或者 MTU 大小)、接收到报文的速率太快，都可能导致 linux 因为缓存满而直接丢包的情况。</p><p>使用<code>sysctl -a |grep net.core</code>查看相关参数设置</p><p>重点看这几个参数：</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_max</strong>：允许设置的 receive buffer 最大值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_default</strong>：默认使用的 receive buffer 值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_max</strong>：允许设置的 send buffer 最大值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_dafault</strong>：默认使用的 send buffer 最大值</p><p>但是这些初始值并不是为了应对大流量的 UDP 报文，如果应用程序接收和发送 UDP 报文非常多，把这个值调大。</p><p>如果发现某些参数设置不合理需要修改的话：</p><p><strong>方法一</strong>：使用 sysctl 命令让它立即生效</p><p>接收最大值设置 sysctl -w net.core.rmem_max&#x3D;56214400 # 设置为 50M</p><p>接收默认值设置 sysctl -w net.core.rmem_default&#x3D;26214400 # 设置为 25M</p><p>发送最大值 sysctl -w net.core.wmem_max&#x3D;26214400 # 设置为 25M</p><p>发送默认值 sysctl -w net.core.wmem_default&#x3D;26214400 # 设置为 25M</p><p><strong>方法二</strong>：修改对应路径文件的参数或者修改 &#x2F;etc&#x2F;sysctl.conf 中对应的参数在下次启动时让参数保持生效（sysctl -p  生效）</p><blockquote><p>3、应用阶段</p></blockquote><p>系统的 UDP buffer size，调节的 sysctl 参数只是系统允许的最大值，每个应用程序在创建 socket 时需要设置自己 socket buffer size 的值。linux 系统会把接受到的报文放到 socket 的 buffer 中，应用程序从 buffer 中不断地读取报文。</p><p>另外一个因素是应用读取 buffer 中报文的速度，对于应用程序来说，处理报文应该采取异步的方式。</p><p>其他可能原因：</p><p>检查防火墙状态 <code>systemctl status firewalld</code>，或者 <code>iptables</code> 阻断了部分流量？</p><p>要处理的实际业务中，每一个连接会占用一个句柄，测试有反馈有 <em>“Too many open files”</em> 的错误。这可能导致数据丢失而没有正确执行实际业务。</p><p>陆续学习和更新</p><p><a href="https://blog.csdn.net/weixin_40754332/article/details/106924810">参考链接：数据传输过程中丢包分析处理</a></p><p>此外补充下小工具的使用</p><ul><li>netstat   主要是用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字。</li></ul><p><strong>-a</strong>      显示所有连接</p><p><strong>-t</strong>      TCP连接</p><p><strong>-u</strong>      UDP连接</p><p><strong>-l</strong>       列出所有处于监听状态的 Sockets</p><p><strong>-s</strong>      显示所有端口的统计信息，可配合-u&#x2F;-t使用</p><p><strong>Recv-Q</strong> 表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走</p><p><strong>send-Q</strong> 表示本地待发送的数据</p><p>这两个值通常应该为0，如果不为0可能是有问题的。packets在两个队列里都不应该有堆积状态。可接受短暂的非0情况。</p><p><a href="https://blog.csdn.net/wangquan1992/article/details/109508822">参考链接：netstat 命令详解及实现原理</a></p><ul><li>ethtool</li></ul><p><strong>ethtool eth0</strong>       显示网卡状态等信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ohh</title>
      <link href="/2024/05/22/ohh/"/>
      <url>/2024/05/22/ohh/</url>
      
        <content type="html"><![CDATA[<p>重新开始吧~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
