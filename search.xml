<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux网络流量问题排查-UDP丢包</title>
      <link href="/2024/05/22/Linux%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-UDP%E4%B8%A2%E5%8C%85/"/>
      <url>/2024/05/22/Linux%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-UDP%E4%B8%A2%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><em>一直以来对Linux网络这部分了解比较少，解决问题总是没有条理</em></p><p><strong>问题：</strong>遇到一个<strong>UDP丢包</strong>的问题：在测试中，一台VM虚拟机，CPU利用率55%左右，内存利用率7%左右，网卡流量也远没到限制的时候出现了丢包情况**</p><p><strong>验证：</strong><code>netstat -su|grep &quot;packet receive errors&quot;|awk &#39;&#123;print $1&#125;&#39;</code>  ，每30s查看一次，计算这次和上次之间的数值差值发现存在UDP丢包现象。</p><p>首先要看问题出现在哪儿，网络流量的路径是怎样的？</p><blockquote><p>1、网络流量通过有线&#x2F;无线发送到网卡<br>2、网卡驱动读取报文放到ring buffer（此时调用DMA，不经过CPU）<br>3、内核从ring buffer中读取报文进行处理，执行IP层，TCP&#x2F;UDP层逻辑<br>4、把报文发到用户态的socket buffer中，应用程序读取socket buffer并进行处理</p></blockquote><p>可能出现问题的地方：1、网卡处理时丢包   2、内核处理时丢包   3、应用程序处理时</p><blockquote><p>1、网卡阶段：</p></blockquote><p>两种方法：</p><p>(1).  <code>ifconfig</code> 查看 <strong>RX errors dropped</strong></p><p>(2).  <code>ethtool -S eth0 |egrep &quot;err|drop&quot;</code></p><p>如果存在丢包，可以查看网卡的ring buffer size是否设置太小达到瓶颈，使用<code>ethtool -g eth0</code>查看最大值和当前值，使用<code>ethtool -G eth0 rx 1024</code>进行修改</p><p>如果网卡方面没问题，那么尝试内核方面查看</p><blockquote><p>2、内核阶段</p></blockquote><p>linux 系统在接收报文之后，会把报文保存到缓存区中。因为缓存区的大小是有限的，如果出现 UDP 报文过大(超过缓存区大小或者 MTU 大小)、接收到报文的速率太快，都可能导致 linux 因为缓存满而直接丢包的情况。</p><p>使用<code>sysctl -a |grep net.core</code>查看相关参数设置</p><p>重点看这几个参数：</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_max</strong>：允许设置的 receive buffer 最大值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_default</strong>：默认使用的 receive buffer 值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_max</strong>：允许设置的 send buffer 最大值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_dafault</strong>：默认使用的 send buffer 最大值</p><p>但是这些初始值并不是为了应对大流量的 UDP 报文，如果应用程序接收和发送 UDP 报文非常多，把这个值调大。</p><p>如果发现某些参数设置不合理需要修改的话：</p><p><strong>方法一</strong>：使用 sysctl 命令让它立即生效</p><p>接收最大值设置 sysctl -w net.core.rmem_max&#x3D;56214400 # 设置为 50M</p><p>接收默认值设置 sysctl -w net.core.rmem_default&#x3D;26214400 # 设置为 25M</p><p>发送最大值 sysctl -w net.core.wmem_max&#x3D;26214400 # 设置为 25M</p><p>发送默认值 sysctl -w net.core.wmem_default&#x3D;26214400 # 设置为 25M</p><p><strong>方法二</strong>：修改对应路径文件的参数或者修改 &#x2F;etc&#x2F;sysctl.conf 中对应的参数在下次启动时让参数保持生效（sysctl -p  生效）</p><blockquote><p>3、应用阶段</p></blockquote><p>系统的 UDP buffer size，调节的 sysctl 参数只是系统允许的最大值，每个应用程序在创建 socket 时需要设置自己 socket buffer size 的值。linux 系统会把接受到的报文放到 socket 的 buffer 中，应用程序从 buffer 中不断地读取报文。</p><p>另外一个因素是应用读取 buffer 中报文的速度，对于应用程序来说，处理报文应该采取异步的方式。</p><p>其他可能原因：</p><p>检查防火墙状态 <code>systemctl status firewalld</code>，或者 <code>iptables</code> 阻断了部分流量？</p><p>要处理的实际业务中，每一个连接会占用一个句柄，测试有反馈有 <em>“Too many open files”</em> 的错误。这可能导致数据丢失而没有正确执行实际业务。</p><p>陆续学习和更新</p><p><a href="https://blog.csdn.net/weixin_40754332/article/details/106924810">参考链接：数据传输过程中丢包分析处理</a></p><p>此外补充下小工具的使用</p><ul><li>netstat   主要是用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字。</li></ul><p><strong>-a</strong>      显示所有连接</p><p><strong>-t</strong>      TCP连接</p><p><strong>-u</strong>      UDP连接</p><p><strong>-l</strong>       列出所有处于监听状态的 Sockets</p><p><strong>-s</strong>      显示所有端口的统计信息，可配合-u&#x2F;-t使用</p><p><strong>Recv-Q</strong> 表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走</p><p><strong>send-Q</strong> 表示本地待发送的数据</p><p>这两个值通常应该为0，如果不为0可能是有问题的。packets在两个队列里都不应该有堆积状态。可接受短暂的非0情况。</p><p><a href="https://blog.csdn.net/wangquan1992/article/details/109508822">参考链接：netstat 命令详解及实现原理</a></p><ul><li>ethtool</li></ul><p><strong>ethtool eth0</strong>       显示网卡状态等信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ohh</title>
      <link href="/2024/05/22/ohh/"/>
      <url>/2024/05/22/ohh/</url>
      
        <content type="html"><![CDATA[<p>重新开始吧~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
