<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>gdb速查手册</title>
      <link href="/2025/12/31/gdb-usage/"/>
      <url>/2025/12/31/gdb-usage/</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h4><p>有段时间没用gdb了，总是忘性很大，此次边查看边记录一下，方便后续使用。</p><h4 id="1、启动GDB"><a href="#1、启动GDB" class="headerlink" title="1、启动GDB"></a>1、启动GDB</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#启动程序(假设程序名为 your_program)</span><br><span class="line">gdb ./your_program</span><br><span class="line"></span><br><span class="line">#或者attach到正在运行的进程</span><br><span class="line">gdb -p &lt;进程PID&gt;</span><br></pre></td></tr></table></figure><h4 id="2、设置断点"><a href="#2、设置断点" class="headerlink" title="2、设置断点"></a>2、设置断点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">b   设置断点</span><br><span class="line">c   继续执行</span><br><span class="line">客户端请求时，服务端在断点处停下</span><br><span class="line"></span><br><span class="line"># 查看所有断点</span><br><span class="line">info breakpoints</span><br><span class="line"># 或简写</span><br><span class="line">info b</span><br><span class="line">i b</span><br><span class="line"></span><br><span class="line"># 禁用某个断点</span><br><span class="line">disable 1</span><br><span class="line"></span><br><span class="line"># 启用某个断点</span><br><span class="line">enable 1</span><br><span class="line"></span><br><span class="line"># 删除某个断点</span><br><span class="line">delete 1</span><br><span class="line"># 或</span><br><span class="line">d 1</span><br></pre></td></tr></table></figure><h4 id="3、逐行排查"><a href="#3、逐行排查" class="headerlink" title="3、逐行排查"></a>3、逐行排查</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n      # next: 执行下一行(不进入函数内部)</span><br><span class="line">s      # step: 执行下一行(会进入函数内部)</span><br><span class="line">c      # continue: 继续执行到下一个断点</span><br><span class="line">p      # print: 打印变量</span><br><span class="line">bt     # backtrace: 查看调用栈</span><br><span class="line">l      # list: 显示当前代码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># up 1 让你可以查看调用当前函数的上层函数的上下文和变量，但不会改变程序执行状态，只是改变你查看的视角。</span><br><span class="line"># 向上移动1层调用栈</span><br><span class="line">up 1</span><br><span class="line"></span><br><span class="line"># 向下移动1层调用栈</span><br><span class="line">down 1</span><br><span class="line"></span><br><span class="line"># 查看当前调用栈</span><br><span class="line">bt        # backtrace，显示完整调用栈</span><br><span class="line">frame     # 显示当前栈帧信息</span><br></pre></td></tr></table></figure><h4 id="4、常用快捷操作"><a href="#4、常用快捷操作" class="headerlink" title="4、常用快捷操作"></a>4、常用快捷操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前代码位置</span><br><span class="line">(gdb) l                    # list: 显示当前行附近的代码</span><br><span class="line">(gdb) l 150                # 显示第150行附近的代码</span><br><span class="line"></span><br><span class="line"># 查看调用栈</span><br><span class="line">(gdb) bt                   # 查看完整调用栈</span><br><span class="line">(gdb) frame 1              # 切换到上一层调用栈</span><br><span class="line">(gdb) info locals          # 查看当前函数的所有局部变量</span><br><span class="line">(gdb) info args            # 查看函数参数</span><br><span class="line"></span><br><span class="line"># 直接执行到某一行</span><br><span class="line">(gdb) until 160            # 执行到第160行</span><br><span class="line"></span><br><span class="line"># 跳过循环</span><br><span class="line">(gdb) until                # 执行完当前循环</span><br><span class="line"></span><br><span class="line"># 退出函数</span><br><span class="line">(gdb) finish               # 执行完当前函数并返回</span><br></pre></td></tr></table></figure><h4 id="5、退出"><a href="#5、退出" class="headerlink" title="5、退出"></a>5、退出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">quit                 # 退出GDB</span><br><span class="line">q                    # 简写</span><br><span class="line"># 如果程序还在运行，会提示确认</span><br><span class="line"># 强制退出（不提示）</span><br><span class="line">quit -y</span><br><span class="line"></span><br><span class="line">#结束当前程序执行</span><br><span class="line">kill                 # 杀死正在调试的程序</span><br><span class="line">k                    # 简写</span><br><span class="line"># GDB本身不退出，可以重新run</span><br><span class="line"></span><br><span class="line">continue             # 继续执行直到结束或下一个断点</span><br><span class="line">c                    # 简写</span><br><span class="line"></span><br><span class="line">finish               # 执行完当前函数并返回</span><br><span class="line">fin                  # 简写</span><br><span class="line"></span><br><span class="line">until                # 执行到当前循环结束</span><br><span class="line">u                    # 简写</span><br><span class="line"></span><br><span class="line">until &lt;line&gt;         # 执行到指定行</span><br><span class="line">u 100                # 执行到第100行</span><br></pre></td></tr></table></figure><h4 id="6、快捷指令"><a href="#6、快捷指令" class="headerlink" title="6、快捷指令"></a>6、快捷指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+D               # 等同于quit（需要按两次）</span><br><span class="line">Ctrl+C               # 中断程序执行（进入GDB提示符）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识推荐系统</title>
      <link href="/2025/12/23/recom-system/"/>
      <url>/2025/12/23/recom-system/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>当我们打开短视频、新闻 App、电商平台时，首页往往早已替我们准备好了一份“专属内容列表”。你刷到的视频、看到的商品、读到的文章，很大程度上并不是随机的，而是由一个复杂却高效的系统 - <strong>推荐系统</strong>（Recommender System）计算得出。</p><h3 id="一、推荐系统解决什么问题？"><a href="#一、推荐系统解决什么问题？" class="headerlink" title="一、推荐系统解决什么问题？"></a>一、推荐系统解决什么问题？</h3><p>在海量内容中，帮用户找到“最可能感兴趣的那一小部分”。</p><p><strong>面临的问题：</strong></p><ul><li>内容极多（百万级视频、商品、文章）</li><li>用户注意力有限</li><li>用户需求往往是隐式的、不明确的</li></ul><p>推荐系统的目标并不是“推荐最好的内容”，而是<strong>在合适的时间，把合适的内容，推荐给合适的用户。</strong></p><h3 id="二、一个最基本的推荐系统长什么样？"><a href="#二、一个最基本的推荐系统长什么样？" class="headerlink" title="二、一个最基本的推荐系统长什么样？"></a>二、一个最基本的推荐系统长什么样？</h3><p>召回 -&gt; 排序 -&gt; 策略</p><h4 id="1、召回"><a href="#1、召回" class="headerlink" title="1、召回"></a>1、召回</h4><p>从海量内容中“捞一批可能相关的”，目标是快速缩小候选集合，从千万级-&gt;几千。</p><p><strong>召回方式：</strong></p><blockquote><p>基于行为的召回：看过类似内容的用户，也看了什么</p></blockquote><blockquote><p>基于内容的召回：视频标签、商品属性、文章主题相似</p></blockquote><blockquote><p>基于规则的召回：热门、最新、同城</p></blockquote><h4 id="2、排序"><a href="#2、排序" class="headerlink" title="2、排序"></a>2、排序</h4><p>给每个候选内容“打分”。</p><p>召回只是“可能相关”，真正决定展示顺序的是排序模型。</p><p>排序模型的核心问题是：<strong>这个内容，对当前用户“有多大概率会发生正向行为？</strong> 比如会不会点击？会不会看完？会不会点赞 &#x2F; 购买？</p><h4 id="排序模型的输入是什么？"><a href="#排序模型的输入是什么？" class="headerlink" title="排序模型的输入是什么？"></a>排序模型的输入是什么？</h4><p>排序模型并不“直接理解人”，而是看特征：</p><ul><li><p>用户特征<br>年龄段、兴趣偏好、历史行为统计</p></li><li><p>内容特征<br>标签、作者、热度、质量分</p></li><li><p>上下文特征<br>时间、地点、设备、网络</p></li></ul><p>模型输出一个 score（评分），按分数从高到低排序。</p><h4 id="3、策略"><a href="#3、策略" class="headerlink" title="3、策略"></a>3、策略</h4><p>不只是“分高就上”。</p><p>如果只按分数排序，可能会出现问题：</p><ul><li>内容过于单一</li><li>新内容没机会</li><li>商业目标无法保证</li></ul><p>所以最后还会有一层 策略调整：</p><ul><li>多样性控制（不要全是同一类型）</li><li>新内容探索（冷启动）</li><li>商业策略（广告、扶持内容）</li></ul><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>当然，推荐系统远不止这些流程，仅先做一个大概理解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++ header-only library</title>
      <link href="/2025/12/03/header-only-library/"/>
      <url>/2025/12/03/header-only-library/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是-Header-only-Library？"><a href="#1-什么是-Header-only-Library？" class="headerlink" title="1. 什么是 Header-only Library？"></a>1. 什么是 Header-only Library？</h2><p>Header-only 库只提供 <code>.h/.hpp</code> 文件，没有 <code>.cpp</code>，也不生成<br><code>.a/.so</code>。使用时只需：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xxx.hpp&quot;</span></span></span><br></pre></td></tr></table></figure><p>常见例子包括：</p><ul><li><p>Boost 部分库（Asio、Spirit 等）</p></li><li><p>fmt（header-only版本）</p></li><li><p>Catch2</p></li><li><p>nlohmann&#x2F;json</p></li></ul><hr><h2 id="2-为什么只引入头文件就能用？"><a href="#2-为什么只引入头文件就能用？" class="headerlink" title="2. 为什么只引入头文件就能用？"></a>2. 为什么只引入头文件就能用？</h2><h3 id="原理-1：模板必须放在头文件中"><a href="#原理-1：模板必须放在头文件中" class="headerlink" title="原理 1：模板必须放在头文件中"></a>原理 1：模板必须放在头文件中</h3><p>模板代码只有在实例化时才会生成实际函数&#x2F;类，因此模板实现必须放在头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123; data.<span class="built_in">push_back</span>(v); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="原理-2：inline-防止多重定义"><a href="#原理-2：inline-防止多重定义" class="headerlink" title="原理 2：inline 防止多重定义"></a>原理 2：inline 防止多重定义</h3><p>头文件被多个源文件包含，如果函数没有被 <code>inline</code> 修饰会产生 ODR 冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br></pre></td></tr></table></figure><h3 id="原理-3：constexpr-static-函数也适合写在头里"><a href="#原理-3：constexpr-static-函数也适合写在头里" class="headerlink" title="原理 3：constexpr &#x2F; static 函数也适合写在头里"></a>原理 3：constexpr &#x2F; static 函数也适合写在头里</h3><p>这些关键字帮助避免符号冲突。</p><h3 id="原理-4：C-17-inline-变量"><a href="#原理-4：C-17-inline-变量" class="headerlink" title="原理 4：C++17 inline 变量"></a>原理 4：C++17 inline 变量</h3><p>允许定义头文件中的全局变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> global_value = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="3-为什么不需要-a-或-so？"><a href="#3-为什么不需要-a-或-so？" class="headerlink" title="3. 为什么不需要 .a 或 .so？"></a>3. 为什么不需要 .a 或 .so？</h2><p>因为 header-only 库的代码是在 <strong>使用者编译阶段</strong>生成的，而不是预编译为目标文件。</p><p>传统库：</p><pre><code>库.cpp → .o → .a / .so → 链接</code></pre><p>Header-only：</p><pre><code>用户.cpp + 库.hpp → 一起编译 → 可执行文件</code></pre><hr><h2 id="4-哪些库不能只靠头文件使用？"><a href="#4-哪些库不能只靠头文件使用？" class="headerlink" title="4. 哪些库不能只靠头文件使用？"></a>4. 哪些库不能只靠头文件使用？</h2><p>以下情况一般无法 header-only： </p><ul><li>大量非模板函数 - 需要隐藏实现 </li><li>使用汇编优化 - 依赖系统库 - 提供 C 接口</li></ul><p>例如： - OpenSSL、OpenCV、gRPC 等都必须链接。</p><hr><h2 id="5-如何判断库是否是-header-only？"><a href="#5-如何判断库是否是-header-only？" class="headerlink" title="5. 如何判断库是否是 header-only？"></a>5. 如何判断库是否是 header-only？</h2><table><thead><tr><th>判断方式</th><th>结论</th></tr></thead><tbody><tr><td>有没有 <code>.cpp</code>  ？</td><td>有 → 要链接</td></tr><tr><td>文档是否写 header-only？</td><td>写了 → 是</td></tr><tr><td>是否大量模板？</td><td>可能是</td></tr><tr><td>是否只需 include 就能用？</td><td>大概率是</td></tr></tbody></table><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>C++<br>只包含头文件就能使用，是因为库将所有实现写入模板、inline、constexpr，使编译器在用户代码编译阶段直接生成最终代码，不需要预编译静态或动态库。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP与RPC各自适用场景？</title>
      <link href="/2025/12/02/httpvsrpc/"/>
      <url>/2025/12/02/httpvsrpc/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-与-RPC-是什么？"><a href="#HTTP-与-RPC-是什么？" class="headerlink" title="HTTP 与 RPC 是什么？"></a>HTTP 与 RPC 是什么？</h2><p><code>HTTP</code>是位于YTCP&#x2F;IP协议栈的应用层协议（超文本传输协议 - HyperText Transfer Protocol）。</p><p><code>RPC</code>是一种抽象机制&#x2F;模式。</p><h2 id="各自适用场景"><a href="#各自适用场景" class="headerlink" title="各自适用场景"></a>各自适用场景</h2><ul><li><p>对外服务、跨平台、多端访问、需要标准化 → 用 HTTP</p></li><li><p>服务间内部调用、要求高性能、高吞吐、低延迟 → 用 RPC</p></li></ul><h2 id="什么时候用HTTP（RESTful-JSON）"><a href="#什么时候用HTTP（RESTful-JSON）" class="headerlink" title="什么时候用HTTP（RESTful&#x2F;JSON）"></a>什么时候用HTTP（RESTful&#x2F;JSON）</h2><h3 id="1-对外提供-API（公网上跑）"><a href="#1-对外提供-API（公网上跑）" class="headerlink" title="1. 对外提供 API（公网上跑）"></a>1. 对外提供 API（公网上跑）</h3><p>例如：</p><p>App 调用你的后端</p><p>Web 前端调用你的服务</p><p>小程序 &#x2F; 桌面端</p><p>第三方合作方</p><p><strong>理由：</strong></p><p>HTTP 是所有平台天然支持的</p><p>JSON 格式通用易调试</p><p>浏览器原生支持</p><p>更容易做文档与调试</p><h3 id="2-需要跨语言、多端、公开标准"><a href="#2-需要跨语言、多端、公开标准" class="headerlink" title="2. 需要跨语言、多端、公开标准"></a>2. 需要跨语言、多端、公开标准</h3><p>iOS &#x2F; Android &#x2F; Web &#x2F; Python &#x2F; Go &#x2F; C++</p><p>第三方厂商接入</p><p>RPC 不方便（要 SDK），但 HTTP 人人都能用。</p><h3 id="3-网络环境复杂，链路不稳定"><a href="#3-网络环境复杂，链路不稳定" class="headerlink" title="3. 网络环境复杂，链路不稳定"></a>3. 网络环境复杂，链路不稳定</h3><p>HTTP 自带：</p><p>重试</p><p>超时</p><p>状态码语义</p><p>代理 &#x2F; 网关支持</p><p>移动网络场景非常依赖。</p><h3 id="4-你需要网关、负载均衡、CDN"><a href="#4-你需要网关、负载均衡、CDN" class="headerlink" title="4. 你需要网关、负载均衡、CDN"></a>4. 你需要网关、负载均衡、CDN</h3><p>HTTP 在基础设施上是最成熟的。</p><h3 id="5-强调资源模型（CRUD-风格）"><a href="#5-强调资源模型（CRUD-风格）" class="headerlink" title="5. 强调资源模型（CRUD 风格）"></a>5. 强调资源模型（CRUD 风格）</h3><p>比如：</p><p>&#x2F;users</p><p>&#x2F;books&#x2F;{id}</p><p>RESTful 感觉更自然。</p><h2 id="什么时候用-RPC（gRPC-Thrift-TCP-自定义协议）"><a href="#什么时候用-RPC（gRPC-Thrift-TCP-自定义协议）" class="headerlink" title="什么时候用 RPC（gRPC &#x2F; Thrift &#x2F; TCP 自定义协议）"></a>什么时候用 RPC（gRPC &#x2F; Thrift &#x2F; TCP 自定义协议）</h2><h3 id="1-内部微服务之间的通信（最典型）"><a href="#1-内部微服务之间的通信（最典型）" class="headerlink" title="1. 内部微服务之间的通信（最典型）"></a>1. 内部微服务之间的通信（最典型）</h3><p>例如：</p><p>用户服务 → 订单服务</p><p>支付服务 → 风控服务</p><p>推荐服务 → 特征服务</p><p>内部服务调用频次极高，延迟要求严格，需要更高性能。</p><h3 id="2-要求高性能、低延迟"><a href="#2-要求高性能、低延迟" class="headerlink" title="2. 要求高性能、低延迟"></a>2. 要求高性能、低延迟</h3><p>相比 HTTP：</p><table><thead><tr><th align="left">协议</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left">HTTP&#x2F;JSON</td><td align="left">文本 + 大量 header，序列化慢</td></tr><tr><td align="left">RPC&#x2F;Protobuf</td><td align="left">二进制 + 高效序列化 + 长连接</td></tr></tbody></table><p>性能一般差一个数量级。</p><h3 id="3-需要强类型接口（IDL）"><a href="#3-需要强类型接口（IDL）" class="headerlink" title="3. 需要强类型接口（IDL）"></a>3. 需要强类型接口（IDL）</h3><p>RPC 一般使用 protobuf&#x2F;thrift IDL：</p><p>自动生成服务端和客户端代码</p><p>参数&#x2F;返回值强类型</p><p>减少手写错误</p><p>非常适合集群化、接口多的系统。</p><h3 id="4-内部服务之间-QPS-非常高"><a href="#4-内部服务之间-QPS-非常高" class="headerlink" title="4. 内部服务之间 QPS 非常高"></a>4. 内部服务之间 QPS 非常高</h3><p>例如：</p><p>一个请求要链式调用 10 次内部接口</p><p>推荐&#x2F;广告系统每秒几十万请求</p><p>HTTP 做不动，RPC 才扛得住。</p><h3 id="5-要长连接、双向流"><a href="#5-要长连接、双向流" class="headerlink" title="5. 要长连接、双向流"></a>5. 要长连接、双向流</h3><p>例如 gRPC 支持：</p><p>双向流</p><p>服务端推送</p><p>客户端流</p><p>HTTP&#x2F;JSON 基本不行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>维度</th><th>HTTP</th><th>RPC</th></tr></thead><tbody><tr><td>性能</td><td>中等</td><td>极高</td></tr><tr><td>延迟</td><td>高</td><td>低</td></tr><tr><td>跨平台兼容性</td><td>非常好</td><td>需要 SDK</td></tr><tr><td>调试难度</td><td>简单（curl&#x2F;浏览器）</td><td>较复杂</td></tr><tr><td>数据格式</td><td>JSON 文本</td><td>Protobuf 等二进制</td></tr><tr><td>连接方式</td><td>短连接为主</td><td>长连接（HTTP&#x2F;2&#x2F;TCP）</td></tr><tr><td>类型安全</td><td>弱</td><td>强</td></tr><tr><td>适用对象</td><td>外部客户端</td><td>内部后端服务</td></tr><tr><td>基础设施支持</td><td>网关&#x2F;CDN&#x2F;缓存完备</td><td>需要自定义</td></tr><tr><td>文档&#x2F;可读性</td><td>极好</td><td>较弱&#x2F;自动生成</td></tr></tbody></table><p><strong>一句话： HTTP 更通用；RPC 更高性能。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VMware Service某些服务关闭导致虚拟机开机无法获取IP地址</title>
      <link href="/2025/10/02/vm-service/"/>
      <url>/2025/10/02/vm-service/</url>
      
        <content type="html"><![CDATA[<h4 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h4><p>windows下运行着vmware，有一天发现所有虚拟机启动后全部没了IP地址，设置的虚拟机网络为NAT模式。</p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>应该不是虚拟机的问题，此刻想到前些时候由于windows电脑卡顿， 一股脑关闭了了很多自启动的服务，问题关键就在这里！</p><p><code>VMware DHCP Service</code>：负责给虚拟机分配 IP 地址。</p><p><code>VMware NAT Service</code>：负责处理虚拟机进出网络的流量转发。</p><p>这两个服务直接导致NAT服务异常。</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p><code>win + R</code> -&gt; <code>services.msc</code> -&gt; <code>找到VMware DHCP Service 和 VMware NAT Service右键启用</code> -&gt; <code>重启虚拟机</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>worm存储机制</title>
      <link href="/2025/06/10/worm-minio/"/>
      <url>/2025/06/10/worm-minio/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-WORM？"><a href="#什么是-WORM？" class="headerlink" title="什么是 WORM？"></a>什么是 WORM？</h2><p>WORM，全称 Write Once Read Many，是一种防篡改存储策略。其核心特征是：对象一旦写入，就不能被修改或删除，直到达到预设的保留期（Retention Period）或者永不删除。</p><h2 id="为什么需要-WORM？"><a href="#为什么需要-WORM？" class="headerlink" title="为什么需要 WORM？"></a>为什么需要 WORM？</h2><p><strong>1.合规性要求</strong></p><p>金融行业要求审计日志不可篡改</p><p>医疗影像、患者记录需保存多年且保持完整性</p><p><strong>2.防止误删&#x2F;恶意删除</strong></p><p>即便管理员也不能轻易删除或覆盖数据</p><p><strong>3.数据长期归档</strong></p><p>冷数据存储，保障长期读取需求</p><h2 id="MinIO-中的-WORM-实现方式"><a href="#MinIO-中的-WORM-实现方式" class="headerlink" title="MinIO 中的 WORM 实现方式"></a>MinIO 中的 WORM 实现方式</h2><p>MinIO 的 WORM 功能基于 对象锁定机制（Object Locking），通过为对象设定不可变的保留时间，来确保其不可被覆盖或删除。</p><p>MinIO 支持两种 WORM 模式：</p><ul><li>Governance 治理模式：对象不可被删除或覆盖，但管理员拥有绕过权限</li><li>Compliance 合规模式：对象不可被任何人删除，即便是管理员，直到保留期结束</li></ul><h2 id="在-MinIO-上启用-WORM"><a href="#在-MinIO-上启用-WORM" class="headerlink" title="在 MinIO 上启用 WORM"></a>在 MinIO 上启用 WORM</h2><h3 id="1-创建支持对象锁定的桶"><a href="#1-创建支持对象锁定的桶" class="headerlink" title="1.创建支持对象锁定的桶"></a>1.创建支持对象锁定的桶</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc mb --with-lock local/worm-bucket</span><br></pre></td></tr></table></figure><p><code>--with-lock</code>参数必须在桶创建时指定，已存在的桶不能开启 WORM</p><h3 id="2-设置默认的-WORM-保留策略"><a href="#2-设置默认的-WORM-保留策略" class="headerlink" title="2.设置默认的 WORM 保留策略"></a>2.设置默认的 WORM 保留策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mc retention set  --default GOVERNANCE 30d local/worm-bucket</span><br><span class="line"></span><br><span class="line">#检查桶状态</span><br><span class="line">mc stat local/worm-bucket</span><br></pre></td></tr></table></figure><p>新上传的对象将在默认保留期内（30 天）不可被删除或修改。</p><h3 id="3-上传文件测试"><a href="#3-上传文件测试" class="headerlink" title="3.上传文件测试"></a>3.上传文件测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;tttyyy&quot; &gt; file1</span><br><span class="line">#上传对象</span><br><span class="line">mc cp file1 local/worm-bucket/</span><br><span class="line"></span><br><span class="line">#删除对象</span><br><span class="line">mc rm local/worm-bucket/file1</span><br><span class="line">Created delete marker `local/worm-bucket/file1` (versionId=c5c45b73-624b-4812-b80f-4f154dd8b717).</span><br></pre></td></tr></table></figure><p>尝试使用 MinIO 客户端（mc）删除 <code>local/worm-bucket</code> 存储桶中的文件 <code>file1</code>，但命令并没有直接删除文件，而是创建了一个<code>删除标记（Delete Marker）</code>，并且返回了<code>版本 ID（versionId=c5c45b73-624b-4812-b80f-4f154dd8b717）</code>。<br>删除标记是一个特殊的对象版本，隐藏了文件的最新版本，但文件的实际数据仍然保留。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#再次上传文件</span><br><span class="line">mc cp file1 local/worm-bucket/</span><br><span class="line"></span><br><span class="line">#列出对象版本信息</span><br><span class="line">mc ls --versions local/worm-bucket/file1</span><br><span class="line">[2025-06-10 06:14:00 UTC]     7B STANDARD b45836ef-c702-46be-abe3-f4f42f302b54 v3 PUT file1</span><br><span class="line">[2025-06-10 06:05:40 UTC]     0B STANDARD c5c45b73-624b-4812-b80f-4f154dd8b717 v2 DEL file1</span><br><span class="line">[2025-06-10 06:05:01 UTC]     7B STANDARD 547fba0d-dfb6-4df1-9684-f38d12356795 v1 PUT file1</span><br><span class="line"></span><br><span class="line">#查看文件的保留状态</span><br><span class="line">mc retention info local/worm-bucket/file1</span><br><span class="line">Name    : local/worm-bucket/file1</span><br><span class="line">Mode    : GOVERNANCE, expiring in 29 days</span><br></pre></td></tr></table></figure><p>Legal Hold 独立于 Governance 或 Compliance 模式的保留策略。一个对象可以同时有 Legal Hold 和保留期。在 Legal Hold 生效期间，即使 Governance 模式的保留期结束或有 s3:BypassGovernanceRetention 权限，也无法删除对象。</p><p>Legal Hold 无时间限制，需手动解除，适合法律或合规场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#检查legalhold持有状态</span><br><span class="line">bash-5.1# mc legalhold info local/worm-bucket/file1</span><br><span class="line">[  Not set ]  file1</span><br><span class="line"></span><br><span class="line">#设置legalhold</span><br><span class="line">mc legalhold set local/worm-bucket/file1</span><br><span class="line"></span><br><span class="line">#解除legalhold</span><br><span class="line">mc legalhold clear local/worm-bucket/file1</span><br></pre></td></tr></table></figure><h3 id="4-管理员强制删除（仅适用于-Governance-模式）"><a href="#4-管理员强制删除（仅适用于-Governance-模式）" class="headerlink" title="4.管理员强制删除（仅适用于 Governance 模式）"></a>4.管理员强制删除（仅适用于 Governance 模式）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#直接删除特定版本的文件</span><br><span class="line">bash-5.1# mc rm --version-id c5c45b73-624b-4812-b80f-4f154dd8b717 --bypass local/worm-bucket/file1</span><br><span class="line">Removed `local/worm-bucket/file1` (versionId=c5c45b73-624b-4812-b80f-4f154dd8b717).</span><br><span class="line"></span><br><span class="line">#删除文件的所有版本</span><br><span class="line">mc rm --versions --bypass --force local/worm-bucket/file1</span><br></pre></td></tr></table></figure><p>如果无法删除，需要确认当前是否有相关权限（可能会出现一些问题）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mc admin policy info local &lt;policy-name&gt;</span><br><span class="line"></span><br><span class="line">cat &gt; policy.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">    &quot;Statement&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">            &quot;Action&quot;: [</span><br><span class="line">                &quot;s3:BypassGovernanceRetention&quot;,</span><br><span class="line">                &quot;s3:PutObjectLegalHold&quot;,</span><br><span class="line">                &quot;s3:DeleteObject&quot;,</span><br><span class="line">                &quot;s3:GetObjectRetention&quot;,</span><br><span class="line">                &quot;s3:GetObjectLegalHold&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Resource&quot;: &quot;arn:aws:s3:::worm-bucket/*&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">mc admin policy create local bypass-policy policy.json</span><br><span class="line">mc admin policy attach local bypass-policy --user user001</span><br></pre></td></tr></table></figure><h3 id="5-Compliance-模式（不可绕过）"><a href="#5-Compliance-模式（不可绕过）" class="headerlink" title="5.Compliance 模式（不可绕过）"></a>5.Compliance 模式（不可绕过）</h3><p>在 Compliance 模式下，文件在保留期内无法删除，即使是管理员也无权绕过。你必须等待保留期结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看文件的保留状态</span><br><span class="line">mc retention info local/worm-bucket/file1</span><br><span class="line">Name    : local/worm-bucket/file1</span><br><span class="line">Mode    : GOVERNANCE, expiring in 29 days</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么我抛弃了 Nginx，转投 Caddy？</title>
      <link href="/2025/05/29/caddy/"/>
      <url>/2025/05/29/caddy/</url>
      
        <content type="html"><![CDATA[<p>作为一名后端开发、运维或架构师，Nginx 一直是我们手上的常用工具：反向代理、静态文件托管、负载均衡、SSL 终端……几乎一网打尽。</p><p>但是，随着项目的演进、需求的变化、心态的变化，我发现 Nginx 渐渐有点“不合胃口”了。于是，我开始尝试 <strong>Caddy</strong>，并一步步把一些场景切换了过去。</p><p>这篇文章，就是聊聊我为什么做出这个决定，<strong>以及 Caddy 更适合在哪些场景下</strong>。</p><hr><h2 id="Nginx-的问题：强大，但复杂、繁琐"><a href="#Nginx-的问题：强大，但复杂、繁琐" class="headerlink" title="Nginx 的问题：强大，但复杂、繁琐"></a>Nginx 的问题：强大，但复杂、繁琐</h2><p>Nginx 非常强大，尤其在大流量、高并发场景下，稳定可靠、性能优越。</p><p>但随着时间推移，我发现：</p><ul><li>配置复杂：想加 HTTPS？得手动生成证书、写配置、定时续签。</li><li>学习曲线高：配置语言不直观，新人需要花时间去学。</li><li>动态需求弱：要容器发现、自动路由？得靠 Lua 脚本或第三方模块。</li><li>扩展能力弱：插件生态有限，很多特性需要打补丁、手动折腾。</li></ul><p><strong>适用场景：</strong></p><blockquote><p> 企业级、高并发、大规模生产环境，需高度可控的负载均衡、精细调优。<br> 对性能和成熟度有极高要求的场合。<br> 需要复杂流量管控（如 A&#x2F;B 测试、灰度发布）的大型集群。</p></blockquote><hr><h2 id="Caddy-的亮点：开箱即用、自动化、现代化"><a href="#Caddy-的亮点：开箱即用、自动化、现代化" class="headerlink" title="Caddy 的亮点：开箱即用、自动化、现代化"></a>Caddy 的亮点：开箱即用、自动化、现代化</h2><p>Caddy 是一款用 Go 编写的现代 Web 服务器，它主打“自动化”、“易用性”、“现代特性”，对比 Nginx，有这些核心优势：</p><p><strong>自动 HTTPS</strong></p><ul><li>内置 Let’s Encrypt，自动申请、续签 SSL，完全免手工。  </li><li>一行配置搞定 HTTPS，让网站更安全。</li></ul><p><strong>配置简洁直观</strong></p><ul><li>Caddyfile 配置极简（如 <code>reverse_proxy</code> 就能代理后端）。  </li><li>支持 JSON 配置，适合自动化、代码生成。</li></ul><p><strong>插件生态强</strong></p><ul><li>活跃的插件系统，扩展性强。</li><li>无需重编译、打补丁，直接使用社区插件。</li></ul><p><strong>动态服务发现友好</strong></p><ul><li>自动检测 Docker、Kubernetes 后端服务，动态热加载配置。  </li><li>不用重启服务，变更秒生效。</li></ul><p><strong>现代协议支持</strong></p><ul><li>内置 HTTP&#x2F;2、HTTP&#x2F;3（QUIC）、TLS 1.3 支持，直接享受最新协议优势。</li></ul><p><strong>开源与商业版并行</strong></p><ul><li>免费开源可用，同时提供商业支持，灵活选择。</li></ul><hr><h2 id="适用场景：Caddy-发挥优势的地方"><a href="#适用场景：Caddy-发挥优势的地方" class="headerlink" title="适用场景：Caddy 发挥优势的地方"></a>适用场景：Caddy 发挥优势的地方</h2><table><thead><tr><th>场景</th><th>Nginx 表现</th><th>Caddy 优势</th></tr></thead><tbody><tr><td><strong>小型静态网站</strong></td><td>配置繁琐（手工证书、复杂目录配置）</td><td>自动 HTTPS、配置极简，几分钟上线</td></tr><tr><td><strong>个人或小团队项目</strong></td><td>大材小用、维护成本高</td><td>易上手、零维护、轻量级</td></tr><tr><td><strong>开发和测试环境</strong></td><td>需要配置模板、反复调试</td><td>即写即用，开发体验极佳</td></tr><tr><td><strong>Docker&#x2F;K8s 微服务</strong></td><td>需复杂脚本实现动态代理</td><td>自动服务发现、动态配置</td></tr><tr><td><strong>需要现代协议支持</strong></td><td>需额外模块、手动配置</td><td>原生支持 HTTP&#x2F;2、HTTP&#x2F;3</td></tr><tr><td><strong>希望扩展能力强</strong></td><td>插件少、生态小</td><td>插件丰富、社区活跃</td></tr></tbody></table><p><strong>总结一句话：</strong></p><blockquote><p><strong>Caddy 更适合小型项目、快速部署、容器化环境、现代化协议和自动化场景。</strong><br><strong>Nginx 更适合极高并发、超复杂流量场景下的生产级大规模集群。</strong></p></blockquote><h2 id="用更少的配置，做更多的事"><a href="#用更少的配置，做更多的事" class="headerlink" title="用更少的配置，做更多的事"></a>用更少的配置，做更多的事</h2><p>从 Nginx 到 Caddy，我感受到的不只是工具的切换，更是一种心态的转变：</p><blockquote><p>不再迷恋复杂，而是追求简洁；不再强调控制，而是拥抱自动化。</p></blockquote><p>如果你也厌倦了为 Nginx 写长长的配置文件、维护繁琐的证书，试试 Caddy，也许你会发现一个更清凉、更现代的世界。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么我抛弃了 Postman，转投 Hoppscotch？</title>
      <link href="/2025/05/29/hoppscotch/"/>
      <url>/2025/05/29/hoppscotch/</url>
      
        <content type="html"><![CDATA[<p>作为一名开发者，API 调试工具是我日常工作不可或缺的一部分。曾经，Postman 是我工作中的首选，但最近，我彻底切换到了 Hoppscotch。这篇文章简单聊聊我为什么做出这个决定。</p><p><a href="https://github.com/hoppscotch/hoppscotch">hoppscotch github仓库</a></p><p><a href="https://hoppscotch.io/">hoppscotch web版本</a></p><p><strong>1. 轻量、开源、速度快</strong><br>Postman 的确功能强大，但随着版本更新，它变得越来越臃肿，启动缓慢、占用内存多。<br>相比之下，Hoppscotch 是纯 Web 版（也有桌面版），开源、免费、界面简洁，打开浏览器就能用，几乎秒开，对我这种追求效率的人来说太友好了。</p><p><strong>2. 更好的跨平台体验</strong><br>Postman 桌面版虽然强大，但 Web 版体验一般。而 Hoppscotch 从一开始就是为 Web 打造的，PC、平板、甚至手机浏览器都能流畅运行，不需要额外安装。随时随地，只要有浏览器，就能调试接口，这让我感到非常自由。</p><p><strong>3. 开发者友好、极简主义设计</strong><br>Postman 近年来越来越偏向企业功能，团队协作、测试套件、监控等等，但这些我平时用得很少。Hoppscotch 的设计更专注于开发者日常最常用的 API 调试，界面干净、上手快、没有多余的负担。</p><p><strong>4. 开源社区和可扩展性</strong><br>作为开源工具，Hoppscotch 背后有活跃的社区和贡献者，这意味着它更加透明、可定制。我喜欢能参与到工具生态中、甚至自己动手修改和贡献的感觉，这也是 Postman 无法比拟的。</p><p><strong>5. 够用就是最好的</strong><br>对我来说，工具不是越多功能越好，而是恰到好处、专注核心需求。Hoppscotch 没有 Postman 那么多企业级功能，但对于个人开发者、自由职业者、小团队，它已经完全够用了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL 中的“postgres”数据库是做什么的？系统表、全局配置都存在哪里？</title>
      <link href="/2025/04/18/postgres-default-conf/"/>
      <url>/2025/04/18/postgres-default-conf/</url>
      
        <content type="html"><![CDATA[<p>在使用 PostgreSQL 的过程中，会注意到数据库中存在 postgres 默认数据库，也有一些“奇怪”的表，比如、pg_* 开头的系统表，它们的作用是什么？全局配置、元数据到底存储在哪？</p><h3 id="一、postgres-数据库是做什么的？"><a href="#一、postgres-数据库是做什么的？" class="headerlink" title="一、postgres 数据库是做什么的？"></a>一、postgres 数据库是做什么的？</h3><p>postgres 数据库是 PostgreSQL 安装后默认创建的一个数据库，它的名字来源于 PostgreSQL 的历史（PostgreSQL 原本叫 Postgres）。</p><p>在安装 PostgreSQL 后，系统默认会创建三个数据库：</p><ul><li><p>postgres: 用作默认数据库，常用于测试连接或基本操作。</p></li><li><p>template0: 系统模板数据库，不能修改，通常用于创建新数据库时的只读模板。</p></li><li><p>template1: 系统模板数据库，用户创建新数据库时默认复制此模板。</p></li></ul><p>其中<code>postgres数据库</code>可以作为一个入口，供管理员连接到数据库集群以执行管理任务，例如创建其他数据库、用户或角色。</p><h3 id="二、PostgreSQL-的系统表存储了什么？"><a href="#二、PostgreSQL-的系统表存储了什么？" class="headerlink" title="二、PostgreSQL 的系统表存储了什么？"></a>二、PostgreSQL 的系统表存储了什么？</h3><p>PostgreSQL 使用一组内置的“系统表”来管理数据库自身的元数据。这些表都以 pg_ 开头，位于 pg_catalog 模式（schema）下,他不属于任何一个数据库，可以通过如下命令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT schemaname, tablename</span><br><span class="line">FROM pg_tables</span><br><span class="line">WHERE tableowner = &#x27;postgres&#x27; AND tablespace = &#x27;pg_global&#x27;;</span><br></pre></td></tr></table></figure><p>下面是一些常见系统表的作用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pg_database存储所有数据库的信息</span><br><span class="line">pg_user / pg_roles存储用户和角色的定义</span><br><span class="line">pg_tables所有用户表的列表（视图）</span><br><span class="line">pg_class所有表、索引、序列等对象的元信息</span><br><span class="line">pg_attribute存储每个表的字段信息</span><br><span class="line">pg_proc存储函数（procedure/function）的定义</span><br><span class="line">pg_settings当前数据库运行的参数配置（即 postgresql.conf 内容）</span><br><span class="line">pg_stat_activity当前连接和活动会话的信息</span><br></pre></td></tr></table></figure><h3 id="三、全局配置存储在哪？"><a href="#三、全局配置存储在哪？" class="headerlink" title="三、全局配置存储在哪？"></a>三、全局配置存储在哪？</h3><p>PostgreSQL 的参数配置大致分三类：</p><p><strong>静态配置文件（无法通过 SQL 修改）</strong></p><ul><li><p>postgresql.conf：大多数运行参数，例如内存、日志等级等</p></li><li><p>pg_hba.conf：连接权限控制</p></li><li><p>pg_ident.conf：用户映射</p></li></ul><p><strong>动态运行参数（可以用 SQL 修改）</strong></p><p>可以通过 SQL 语句 SHOW 查看、SET 修改</p><p>全部参数都可以通过 pg_settings 表来查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, setting, unit, vartype, context, source FROM pg_settings;</span><br></pre></td></tr></table></figure><p>修改参数方式（会话级）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET work_mem = &#x27;64MB&#x27;;</span><br></pre></td></tr></table></figure><p>修改全局参数（永久生效）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER SYSTEM SET work_mem = &#x27;64MB&#x27;;</span><br><span class="line">SELECT pg_reload_conf(); -- 使其生效</span><br></pre></td></tr></table></figure><p>修改后会写入 $PGDATA&#x2F;postgresql.auto.conf 文件。</p><h3 id="四、如何查看这些系统表？"><a href="#四、如何查看这些系统表？" class="headerlink" title="四、如何查看这些系统表？"></a>四、如何查看这些系统表？</h3><p>通过 SQL 查询系统表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 查看所有数据库</span><br><span class="line">SELECT * FROM pg_database;</span><br><span class="line"></span><br><span class="line">-- 查看当前数据库中的表</span><br><span class="line">SELECT * FROM pg_tables WHERE schemaname NOT IN (&#x27;pg_catalog&#x27;, &#x27;information_schema&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查看所有配置参数</span><br><span class="line">SELECT * FROM pg_settings;</span><br><span class="line"></span><br><span class="line">-- 当前连接会话信息</span><br><span class="line">SELECT * FROM pg_stat_activity;</span><br></pre></td></tr></table></figure><p>使用 psql 命令行工具中的元命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\l      -- 列出所有数据库</span><br><span class="line">\d      -- 列出当前数据库中的表</span><br><span class="line">\du     -- 列出所有用户</span><br><span class="line">\conninfo  -- 查看当前连接信息</span><br></pre></td></tr></table></figure><h3 id="五、系统表是否可以修改？"><a href="#五、系统表是否可以修改？" class="headerlink" title="五、系统表是否可以修改？"></a>五、系统表是否可以修改？</h3><p>一般来说，PostgreSQL 的系统表不建议直接修改，因为它们承载了数据库的结构定义,直接 UPDATE 或 DELETE 系统表可能会导致数据库崩溃或无法启动,但可以读取、查询这些表，深入理解数据库的运行机制。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>在 PostgreSQL 中，可以在postgres 默认数据库中创建别的数据库，但不能直接在 postgres 默认数据库中创建其他数据库的表，因为 PostgreSQL 的架构将每个数据库的表和数据严格隔离。每个数据库有自己的系统 каталоги（如 pg_class、pg_attribute）和数据文件，存储在各自的表空间中（通常是 PGDATA&#x2F;base&#x2F;&lt;数据库OID&gt;&#x2F;）。因此，表只能在当前连接的数据库中创建，而无法直接为另一个数据库（如 glacier_meta）创建表。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>驼峰命名（CamelCase）还是下划线命名（snake_case）</title>
      <link href="/2025/04/14/naming-method/"/>
      <url>/2025/04/14/naming-method/</url>
      
        <content type="html"><![CDATA[<h4 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h4><p>通过将单词的首字母大写（或仅首个单词后的单词首字母大写）来组合单词，不使用分隔符。例如，UserName 或 firstName。</p><p>根据首字母是否大写，分为：</p><ul><li><p>UpperCamelCase（如 UserName，也叫 PascalCase）：每个单词首字母大写。</p></li><li><p>lowerCamelCase（如 userName）：首单词小写，其余单词首字母大写。</p></li></ul><p>在数据库中，通常使用 UpperCamelCase 或 lowerCamelCase，但 <code>PostgreSQL 中大小写敏感性</code>会带来额外考虑。</p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li><p>大小写敏感：<br>在 PostgreSQL 中，未加双引号的标识符（如 UserName）会被自动转换为小写（username）。因此，驼峰命名的列名通常需要用双引号定义和查询</p></li><li><p>与 ORM 集成：<br>驼峰命名与 Java、JavaScript 等语言的变量名一致，ORM 框架（如 Hibernate、Sequelize）通常默认映射到 camelCase，减少配置工作。</p></li><li><p>长度：<br>驼峰命名不使用分隔符，列名稍短（例如 UserName 比 user_name 少 1 个字符）。</p></li></ul><h4 id="下划线命名法"><a href="#下划线命名法" class="headerlink" title="下划线命名法"></a>下划线命名法</h4><p>使用小写字母，并以 _ 作为单词之间的分隔符，例如 user_name 或 order_item_total_price。</p><p>通常全小写（snake_case），但在某些场景下可能使用大写（SNAKE_CASE，多见于常量或配置文件）。</p><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><ul><li><p>大小写无关：<br>PostgreSQL 对未加双引号的标识符小写化处理，因此 user_name、USER_NAME 和 User_Name 在查询中是等价的，无需双引号</p></li><li><p>与 SQL 风格一致：<br>下划线命名与 SQL 关键字（如 order_by、group_by）风格一致，查询语句更自然。</p></li><li><p>长度：<br>由于下划线分隔符，列名略长，但对现代数据库的性能影响微乎其微。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊juicefs权限控制</title>
      <link href="/2025/03/11/juicefs-acl/"/>
      <url>/2025/03/11/juicefs-acl/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>项目使用juicefs作为文件系统对外提供服务，元数据存储在postgresql中，数据存储在minio中，同时minio也可以作为对象网关对外提供服务。有部分文件可能会有转储的需求，多用户操作自然会涉及到权限控制，想着了解一下</p><h3 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h3><h4 id="一、文件存储"><a href="#一、文件存储" class="headerlink" title="一、文件存储"></a>一、文件存储</h4><h5 id="在-JuiceFS-挂载时启用-POSIX-ACL"><a href="#在-JuiceFS-挂载时启用-POSIX-ACL" class="headerlink" title="在 JuiceFS 挂载时启用 POSIX ACL"></a>在 JuiceFS 挂载时启用 POSIX ACL</h5><p>JuiceFS 默认启用UID／GID 自动映射，会与本地自动进行同步，此外 JuiceFS 支持 POSIX ACL，可以直接对用户和用户组设置更细粒度的权限。在经过网上查到的使用 <code>-o allow_other,acl</code> 参数挂载时碰壁。</p><blockquote><p><code>allow_other</code>参数：该选项允许其他用户（包括非挂载用户）访问挂载的文件系统，JuiceFS 依赖 FUSE（用户空间文件系统），所以需要安装fuse (centos参考: yum install -y fuse fuse-devel)，此外 <code>allow_other</code> 需要在 <code>/etc/fuse.conf</code> 中启用 <code>user_allow_other</code></p></blockquote><blockquote><p><code>acl</code>参数：启动失败，报错大致是没这个选项! 找资料发现可以在<code>format</code>的时候加上<code>--enable-acl</code>来替代，此外<code>mount</code>时可以加的参数有<code>--enable-xattr</code></p></blockquote><p><code>acl</code> 选项允许使用 setfacl 和 getfacl 命令来管理 ACL 规则。</p><h5 id="使用-setfacl-设定文件和目录权限"><a href="#使用-setfacl-设定文件和目录权限" class="headerlink" title="使用 setfacl 设定文件和目录权限"></a>使用 setfacl 设定文件和目录权限</h5><p>如果希望用户 user1 只能读取 &#x2F;mnt&#x2F;juicefs&#x2F;data 目录，不能删除或修改文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m u:user1:r-- /mnt/juicefs/data</span><br></pre></td></tr></table></figure><p>或者禁止用户 user2 删除 &#x2F;mnt&#x2F;juicefs&#x2F;data&#x2F;file.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m u:user2:-w /mnt/juicefs/data/file.txt</span><br></pre></td></tr></table></figure><p>也可以针对组设定权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m g:group1:r-x /mnt/juicefs/data</span><br></pre></td></tr></table></figure><h4 id="二、对象存储"><a href="#二、对象存储" class="headerlink" title="二、对象存储"></a>二、对象存储</h4><h5 id="配置-MinIO-的-IAM-策略（防止直接访问对象存储）"><a href="#配置-MinIO-的-IAM-策略（防止直接访问对象存储）" class="headerlink" title="配置 MinIO 的 IAM 策略（防止直接访问对象存储）"></a>配置 MinIO 的 IAM 策略（防止直接访问对象存储）</h5><p>对象网关部分用户、用户组权限本文暂未详述，可参考<a href="https://cloud.tencent.com/developer/article/2415323">JuiceFS v1.2-beta1，Gateway 升级，多用户场景权限管理更灵活</a>！</p><p>如果担心用户绕过 JuiceFS 直接访问 MinIO，可以配置 MinIO 的 IAM 策略，限制用户的 API 操作，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot;: &quot;2025-01-01&quot;,</span><br><span class="line">  &quot;Statement&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Effect&quot;: &quot;Deny&quot;,</span><br><span class="line">      &quot;Action&quot;: [&quot;s3:DeleteObject&quot;, &quot;s3:PutObject&quot;],</span><br><span class="line">      &quot;Resource&quot;: [&quot;arn:aws:s3:::juicefs-bucket/*&quot;],</span><br><span class="line">      &quot;Principal&quot;: &#123;&quot;AWS&quot;: [&quot;arn:aws:iam::account-id:user/user1&quot;]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 user1 无法通过 MinIO API 删除或上传对象。</p><h3 id="三、postgresql数据库"><a href="#三、postgresql数据库" class="headerlink" title="三、postgresql数据库"></a>三、postgresql数据库</h3><h4 id="PostgreSQL-层面约束（限制元数据修改）"><a href="#PostgreSQL-层面约束（限制元数据修改）" class="headerlink" title="PostgreSQL 层面约束（限制元数据修改）"></a>PostgreSQL 层面约束（限制元数据修改）</h4><p>JuiceFS 依赖 PostgreSQL 存储元数据，如果不希望某些用户能修改 jfs_node 表中的数据，可以为 PostgreSQL 设定合适的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE UPDATE, DELETE ON jfs_node FROM user1;</span><br></pre></td></tr></table></figure><p>这样 user1 不能直接修改数据库中的元数据，防止通过 SQL 方式篡改文件系统信息。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="setfacl使用"><a href="#setfacl使用" class="headerlink" title="setfacl使用"></a>setfacl使用</h4><ul><li><p>为特定用户添加权限 <code>setfacl -m u:username:rw- /path/to/file</code>，为用户 username 设置对文件的读写权限。</p></li><li><p>为特定组添加权限<code>setfacl -m g:groupname:r-x /path/to/file</code>，为组 groupname 设置读和执行权限。</p></li><li><p>设置默认 ACL（目录） <code>setfacl -m d:u:username:rwx /path/to/dir</code>，新创建的文件或子目录将继承此权限。</p></li><li><p>递归设置 ACL <code>setfacl -R -m u:username:rwx /path/to/dir</code>，递归为目录及其所有内容设置权限。</p></li><li><p>删除特定 ACL 条目<code>setfacl -x u:username /path/to/file</code>，删除用户 username 的 ACL 条目。</p></li><li><p>删除所有扩展 ACL <code>setfacl -b /path/to/file</code>，删除所有扩展 ACL，仅保留基本 POSIX 权限。</p></li></ul><h4 id="getfacl使用"><a href="#getfacl使用" class="headerlink" title="getfacl使用"></a>getfacl使用</h4><ul><li><p>查看文件 ACL <code>getfacl /path/to/file</code></p></li><li><p>查看目录 ACL <code>getfacl /path/to/dir</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> juicefs </tag>
            
            <tag> minio </tag>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go fsnotify 监听程序无法捕获 vim 修改后的文件？</title>
      <link href="/2025/03/04/go-fsnotify/"/>
      <url>/2025/03/04/go-fsnotify/</url>
      
        <content type="html"><![CDATA[<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>当使用 echo 命令修改文件时，监听函数能够正常检测到文件修改事件并生效，但使用 vim 编辑并保存文件后，监听函数无法检测到修改事件</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>vim 在保存文件时，通常不会直接修改原始文件，而是通过以下步骤操作：</p><ul><li><p>1、创建一个临时文件，写入修改后的内容。</p></li><li><p>2、删除原始文件。</p></li><li><p>3、将临时文件重命名为原始文件名。</p></li></ul><p>这种操作方式可能导致文件监听工具（例如 Go 的 fsnotify 库）无法捕获到预期的写事件</p><p>（fsnotify.Write），因为实际发生的事件可能是删除（fsnotify.Remove）或重命名</p><p>（fsnotify.Rename），而不是简单的写入。</p><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>为了支持 vim 的修改行为，需要改进监听函数，使其不仅监听写事件，还能处理删除和重命名事件，并在文件被删除或重命名后重新添加监听。以下是具体步骤和实现：</p><h5 id="1、扩展事件监听"><a href="#1、扩展事件监听" class="headerlink" title="1、扩展事件监听"></a>1、扩展事件监听</h5><p>除了监听写事件（fsnotify.Write），还需要监听：</p><ul><li><p>删除事件（fsnotify.Remove）：当原始文件被删除时触发。</p></li><li><p>重命名事件（fsnotify.Rename）：当临时文件被重命名为原始文件名时触发。</p></li></ul><h4 id="2、重新添加监听"><a href="#2、重新添加监听" class="headerlink" title="2、重新添加监听"></a>2、重新添加监听</h4><p>当检测到文件被删除或重命名时，监听器会丢失对文件的跟踪。因此，需要在事件发生后重新将文件添加到监听器中，确保持续监控。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于juicefs删除文件后仍然存在残留临时文件解决</title>
      <link href="/2025/02/20/juicefs-gc/"/>
      <url>/2025/02/20/juicefs-gc/</url>
      
        <content type="html"><![CDATA[<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>juicefs 使用 postgresql 作为元数据引擎，minio 作为对象存储，当从 juicefs 一侧删除文件之后，发现 pg 中仍然存在很多元数据信息，解析 <code>jfs_edge</code>中的文件名之后发现都是一些<code>swp</code>残留文件，去 minio 中查看也确实都存在</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><h5 id="1、回收站功能："><a href="#1、回收站功能：" class="headerlink" title="1、回收站功能："></a>1、回收站功能：</h5><p>JuiceFS 默认启用了回收站功能，被删除的文件会被移入回收站，而不是立即从对象存储中删除。因此，即使在文件系统中删除了文件，回收站中的文件仍然存在，且仍会被 PostgreSQL 记录。要彻底删除文件，需要清空回收站。</p><h5 id="2、异步删除："><a href="#2、异步删除：" class="headerlink" title="2、异步删除："></a>2、异步删除：</h5><p>JuiceFS 的删除操作是异步的，文件删除请求会被提交到后台任务，实际删除可能会有延迟。因此，删除操作可能尚未完成，导致 PostgreSQL 中仍然存在 .swp 文件的记录。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>juicefs gc --delete $META-URL </code></p><p>忘记格式可以参考 (postgres:&#x2F;&#x2F;juicefs:****@localhost:5432&#x2F;bucket6)</p><p><img src="/../images/juicefs-gc/juicefs_gc.png" alt="image"><br>再次查看就很清爽了</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><code>--delete</code>这个选项会真正删除标记为垃圾的数据。默认情况下，juicefs gc 只会标记垃圾数据，而不会立即删除它们。</p><p><code>--threads</code>这个选项允许你指定垃圾回收的线程数。增加线程数可以提高垃圾回收的速度，但也会消耗更多的系统资源。</p><p><code>--dry-run</code>这个选项允许你进行一次“干运行”，即只列出将被删除的文件，而不实际删除它们。这对于预览垃圾回收的结果非常有用。</p><p><code>--min-age</code> 这个选项允许你指定被认为是垃圾数据的最小年龄。例如，–min-age&#x3D;7d 表示只有超过 7 天没有被访问的数据才会被认为是垃圾数据。</p><p>例如：想删除所有超过 7 天没有被访问的垃圾数据，并使用 4 个线程进行垃圾回收,可以这样写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">juicefs gc --delete --threads=4 --min-age=7d $META-URL</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在运行 juicefs gc 命令之前，建议先使用 –dry-run 选项进行一次“干运行”，以确保你知道哪些数据将被删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> juicefs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离线服务器迁移安装docker镜像</title>
      <link href="/2025/01/10/moveImg/"/>
      <url>/2025/01/10/moveImg/</url>
      
        <content type="html"><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>服务器需要使用容器，但是服务器是离线状态，或者无法直接拉取docker镜像，这时候就需要本篇文章了</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="步骤-1-将镜像导出为-tar-文件"><a href="#步骤-1-将镜像导出为-tar-文件" class="headerlink" title="步骤 1: 将镜像导出为 tar 文件"></a>步骤 1: 将镜像导出为 tar 文件</h5><p>首先，在在线服务器上将镜像导出为一个 .tar 文件。你可以使用 docker save 命令来将镜像导出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o /path/to/your-image.tar your-image:tag</span><br></pre></td></tr></table></figure><p><code>/path/to/your-image.tar</code> 是你要保存镜像文件的路径。</p><p><code>your-image:tag</code> 是你要导出的镜像名称和标签（例如：ubuntu:20.04）。</p><p><strong>补充：</strong></p><p>如果想要将正在运行的容器打包成镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker commit my_container my_new_image:v1.0</span><br><span class="line"># 其中：</span><br><span class="line"># my_container 是容器的名称或 ID。</span><br><span class="line"># my_new_image 是新镜像的名称。</span><br><span class="line"># v1.0 是镜像的标签（可选）。</span><br><span class="line"># 其他选项</span><br><span class="line"># -a, --author string：指定镜像的作者。</span><br><span class="line"># -m, --message string：添加镜像的提交信息。</span><br></pre></td></tr></table></figure><h5 id="步骤-2-将镜像文件传输到离线服务器"><a href="#步骤-2-将镜像文件传输到离线服务器" class="headerlink" title="步骤 2: 将镜像文件传输到离线服务器"></a>步骤 2: 将镜像文件传输到离线服务器</h5><p>将导出的 .tar 文件从在线服务器传输到离线服务器。可以使用任何支持文件传输的工具，如 scp、rsync、USB 存储等。</p><p>如果你有 SSH 访问权限，可以使用 scp 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /path/to/your-image.tar user@offline-server:/path/to/destination/</span><br></pre></td></tr></table></figure><p><code>/path/to/your-image.tar</code> 是本地文件路径。</p><p><code>user@offline-server:/path/to/destination/</code> 是离线服务器的目标路径。</p><h5 id="步骤-3-在离线服务器上加载镜像"><a href="#步骤-3-在离线服务器上加载镜像" class="headerlink" title="步骤 3: 在离线服务器上加载镜像"></a>步骤 3: 在离线服务器上加载镜像</h5><p>在离线服务器上使用 docker load 命令将镜像加载到 Docker 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i /path/to/your-image.tar</span><br></pre></td></tr></table></figure><p><code>/path/to/your-image.tar</code> 是传输过来的镜像文件路径。</p><p>加载成功后，你可以使用 docker images 命令查看是否成功导入镜像。</p><h5 id="步骤-4-启动容器"><a href="#步骤-4-启动容器" class="headerlink" title="步骤 4: 启动容器"></a>步骤 4: 启动容器</h5><p>一旦镜像成功加载，你就可以使用 docker run 启动容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-container your-image:tag</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数是让容器在后台运行。</p><p><code>--name my-container</code> 是容器的名称。</p><p><code>your-image:tag</code> 是加载的镜像名称和标签。</p><h5 id="步骤-5-验证容器是否启动"><a href="#步骤-5-验证容器是否启动" class="headerlink" title="步骤 5: 验证容器是否启动"></a>步骤 5: 验证容器是否启动</h5><p>使用以下命令查看容器是否成功启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>如果容器正在运行，它会出现在列表中。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、使用 docker save 命令将镜像导出为 .tar 文件。<br>2、使用 scp 或其他方式将 .tar 文件传输到离线服务器。<br>3、在离线服务器上使用 docker load 命令加载镜像。<br>4、使用 docker run 命令启动容器。<br>5、这样你就可以成功将镜像从在线服务器迁移到离线服务器并启动容器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解Dockerfile，是什么？主要指令？如何使用？</title>
      <link href="/2025/01/09/Dockerfile/"/>
      <url>/2025/01/09/Dockerfile/</url>
      
        <content type="html"><![CDATA[<h4 id="Dockerfile是什么？"><a href="#Dockerfile是什么？" class="headerlink" title="Dockerfile是什么？"></a>Dockerfile是什么？</h4><p>Dockerfile 是一个文本文件，其中包含了一系列指令，用来自动化构建 Docker 镜像。它的主要作用就是定义一个 Docker 镜像的构建过程，包括镜像的基础镜像、安装的软件、设置的环境变量、暴露的端口、执行的命令等。</p><h4 id="主要指令有哪些？"><a href="#主要指令有哪些？" class="headerlink" title="主要指令有哪些？"></a>主要指令有哪些？</h4><h5 id="1、FROM：指定基础镜像。"><a href="#1、FROM：指定基础镜像。" class="headerlink" title="1、FROM：指定基础镜像。"></a>1、FROM：指定基础镜像。</h5><p><code>FROM ubuntu:20.04</code>，表示使用 ubuntu 20.04 作为基础镜像。</p><h5 id="2、RUN：在镜像构建过程中执行命令（通常用于安装软件）。"><a href="#2、RUN：在镜像构建过程中执行命令（通常用于安装软件）。" class="headerlink" title="2、RUN：在镜像构建过程中执行命令（通常用于安装软件）。"></a>2、RUN：在镜像构建过程中执行命令（通常用于安装软件）。</h5><p><code>RUN apt-get update &amp;&amp; apt-get install -y curl</code>，表示在镜像中安装 curl 软件。</p><h5 id="3、COPY-ADD：将文件从本地复制到镜像中。"><a href="#3、COPY-ADD：将文件从本地复制到镜像中。" class="headerlink" title="3、COPY &#x2F; ADD：将文件从本地复制到镜像中。"></a>3、COPY &#x2F; ADD：将文件从本地复制到镜像中。</h5><p><code>COPY ./myapp /app</code>，表示将当前目录下的 myapp 文件夹复制到镜像中的 &#x2F;app 目录。</p><h5 id="4、WORKDIR：设置工作目录，后续的命令都会在该目录下执行。"><a href="#4、WORKDIR：设置工作目录，后续的命令都会在该目录下执行。" class="headerlink" title="4、WORKDIR：设置工作目录，后续的命令都会在该目录下执行。"></a>4、WORKDIR：设置工作目录，后续的命令都会在该目录下执行。</h5><p><code>WORKDIR /app</code>，设置工作目录为 &#x2F;app。</p><h5 id="5、EXPOSE：暴露容器的端口，供外部访问。"><a href="#5、EXPOSE：暴露容器的端口，供外部访问。" class="headerlink" title="5、EXPOSE：暴露容器的端口，供外部访问。"></a>5、EXPOSE：暴露容器的端口，供外部访问。</h5><p><code>EXPOSE 8080</code>，表示容器会监听 8080 端口。</p><h5 id="6、CMD-ENTRYPOINTCMD-ENTRYPOINT：指定容器启动时执行的命令。"><a href="#6、CMD-ENTRYPOINTCMD-ENTRYPOINT：指定容器启动时执行的命令。" class="headerlink" title="6、CMD &#x2F; ENTRYPOINTCMD &#x2F; ENTRYPOINT：指定容器启动时执行的命令。"></a>6、CMD &#x2F; ENTRYPOINTCMD &#x2F; ENTRYPOINT：指定容器启动时执行的命令。</h5><p>是容器启动时的默认命令，但可以被 docker run 覆盖；ENTRYPOINT 是容器启动时的强制命令。</p><p><code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>，表示容器启动时会执行 python app.py。</p><h4 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ImgName .</span><br></pre></td></tr></table></figure><ul><li><p><code>-t ImgName</code> -t 是 tag 的缩写，用来为新构建的镜像命名和打标签。在这里，ImgName 就是你要给这个镜像命名的名称。</p></li><li><p><code>.</code>  这个点（.）表示当前目录。Docker 将从这个目录下的 Dockerfile 文件开始构建镜像。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解 AI 对话中的 Token？</title>
      <link href="/2024/12/06/AiToken/"/>
      <url>/2024/12/06/AiToken/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是Token？"><a href="#一、什么是Token？" class="headerlink" title="一、什么是Token？"></a>一、什么是Token？</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1. 定义："></a>1. 定义：</h4><p>在自然语言处理（NLP）和AI对话系统中，token通常指的是文本中的一个单元，可以是一个单词、一个标点符号、一个数字，或者甚至是一个子词（如“playing”可以被分成“play”和“##ing”）。</p><h4 id="2-通俗理解："><a href="#2-通俗理解：" class="headerlink" title="2. 通俗理解："></a>2. 通俗理解：</h4><p>想象你正在玩拼图游戏，每个拼图块代表一个单词或符号，这些拼图块就是tokens。AI系统通过识别和处理这些拼图块来理解和生成语言。</p><h3 id="二、Token在AI对话中的作用："><a href="#二、Token在AI对话中的作用：" class="headerlink" title="二、Token在AI对话中的作用："></a>二、Token在AI对话中的作用：</h3><h4 id="1-输入和输出："><a href="#1-输入和输出：" class="headerlink" title="1. 输入和输出："></a>1. 输入和输出：</h4><p>当你向AI输入一句话时，AI首先会将这句话拆分成tokens，然后处理这些tokens来理解你的意思。同样，当AI生成回应时，它也是基于tokens来构建句子。</p><h4 id="2-模型训练："><a href="#2-模型训练：" class="headerlink" title="2. 模型训练："></a>2. 模型训练：</h4><p>在训练AI模型时，token是数据的基本单位。模型通过学习大量的tokens组合来理解语言的结构、语义和语法。</p><h4 id="3-上下文理解："><a href="#3-上下文理解：" class="headerlink" title="3. 上下文理解："></a>3. 上下文理解：</h4><p>Tokens帮助AI理解上下文。通过分析tokens的顺序和它们之间的关系，AI可以理解句子的意思。</p><h4 id="4-效率："><a href="#4-效率：" class="headerlink" title="4. 效率："></a>4. 效率：</h4><p>使用tokens可以提高处理效率，因为AI可以更快地识别和处理预定义的单元，而不是每次都从头开始解析整个文本。</p><h3 id="三、如何理解Token的数量："><a href="#三、如何理解Token的数量：" class="headerlink" title="三、如何理解Token的数量："></a>三、如何理解Token的数量：</h3><ul><li><p>数量：在AI对话中，通常会有一个token数量的限制，因为每个token都需要计算资源来处理。AI系统可能限制一次性处理的token数量，以保持响应的速度和效率。</p></li><li><p>长度限制：例如，一个AI系统可能限制每轮对话处理不超过512个tokens。这意味着你输入的文本和AI生成的文本加起来不能超过这个限制。</p></li></ul><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><ul><li><p>输入：“How are you today?”<br>这个句子可以被分成tokens：[‘How’, ‘are’, ‘you’, ‘today’, ‘?’]</p></li><li><p>处理：AI通过识别这些tokens，理解这是一个问候，并准备一个合适的回答。</p></li><li><p>输出：“I am doing well, thank you for asking!”<br>这里的每个单词或标点符号也是tokens，AI通过组合这些tokens来生成一个自然的回答。</p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Token在AI对话中就像是语言的基本构件块，通过对这些构件块的识别、处理和生成，AI能够模拟人类的语言交流。理解token有助于我们更好地理解AI是如何处理和理解语言的，同时也解释了为什么有些时候AI对话系统会有长度限制或处理时间的考虑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核ceph_mount流程</title>
      <link href="/2024/11/21/ceph-mount%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/11/21/ceph-mount%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="内核ceph-mount流程"><a href="#内核ceph-mount流程" class="headerlink" title="内核ceph_mount流程"></a>内核ceph_mount流程</h2><h3 id="1-用户空间命令行发起-mount-请求"><a href="#1-用户空间命令行发起-mount-请求" class="headerlink" title="1. 用户空间命令行发起 mount 请求"></a>1. 用户空间命令行发起 mount 请求</h3><p><code>mount -t ceph $(hostname):6789:/ /mnt/ceph/ -o name=admin,secret=$(ceph auth get-key client.admin)</code></p><p>执行这条ceph挂载命令时会发生什么？</p><h3 id="2-进入内核-sys-mount-系统调用"><a href="#2-进入内核-sys-mount-系统调用" class="headerlink" title="2. 进入内核 sys_mount 系统调用"></a>2. 进入内核 sys_mount 系统调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,</span><br><span class="line">char __user *, type, unsigned long, flags, void __user *, data)</span><br></pre></td></tr></table></figure><p>sys_mount 接受用户传入的设备名、挂载点、文件系统类型、挂载标志和挂载选项。<br>它将参数传递给 do_mount() 函数，进行更详细的挂载操作。</p><h3 id="3-do-mount-函数"><a href="#3-do-mount-函数" class="headerlink" title="3. do_mount() 函数"></a>3. do_mount() 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long do_mount(const char *dev_name, const char __user *dir_name,</span><br><span class="line">const char *type_page, unsigned long flags, void *data_page)</span><br></pre></td></tr></table></figure><p>do_mount 函数负责解析和检查挂载参数。</p><p>调用 do_new_mount 函数，尝试将文件系统挂载到指定路径。</p><h3 id="4-do-new-mount-函数"><a href="#4-do-new-mount-函数" class="headerlink" title="4. do_new_mount() 函数"></a>4. do_new_mount() 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int do_new_mount(struct path *path, const char *fstype, int flags,</span><br><span class="line">int mnt_flags, const char *name, void *data)</span><br></pre></td></tr></table></figure><p>do_new_mount 主要负责创建 vfsmount 结构并调用 vfs_kern_mount 函数，向虚拟文件系统（VFS）提交挂载请求。</p><p>vfsmount 是一个内核结构体，用于在 VFS 中表示文件系统的挂载点，包含挂载的信息和路径。</p><h3 id="5-vfs-kern-mount-函数"><a href="#5-vfs-kern-mount-函数" class="headerlink" title="5. vfs_kern_mount() 函数"></a>5. vfs_kern_mount() 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct vfsmount *</span><br><span class="line">vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)</span><br></pre></td></tr></table></figure><p>vfs_kern_mount 是挂载路径的关键函数，它通过文件系统类型（file_system_type）找到具体的挂载函数，并创建一个 vfsmount 结构。</p><p>调用 type-&gt;mount()，即调用对应文件系统类型的 mount 函数。</p><p>对于 Ceph 文件系统，file_system_type 是 ceph_fs_type，它的 mount 函数是 ceph_mount()。</p><h3 id="6-ceph-mount-函数"><a href="#6-ceph-mount-函数" class="headerlink" title="6. ceph_mount() 函数"></a>6. ceph_mount() 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static struct dentry *ceph_mount(struct file_system_type *fs_type,</span><br><span class="line">       int flags, const char *dev_name, void *data)</span><br></pre></td></tr></table></figure><p>ceph_mount 是 Ceph 文件系统特有的挂载函数。</p><p>ceph_mount 主要负责初始化 Ceph 文件系统客户端，连接到 Ceph 集群，并创建文件系统的根目录（dentry）。</p><p>ceph_mount 使用 Ceph 的用户态库（libceph）进行 Ceph 集群通信，包括连接到 Ceph Monitor、OSD 等服务。</p><p>挂载成功后返回根目录 dentry 给 VFS。</p><p>详细看一下代码！！！<br><code>ceph mount</code>过程，主要在<code>fs/ceph/super.c</code>文件中。</p><p><code>ceph_mount</code>解析挂载选项，创建文件客户端，初始化mds客户端，然后进入到<code>ceph_real_mount</code>；<code>ceph_real_mount</code> 将客户端节点挂载到 Ceph 文件系统集群，并打开文件系统的根目录。其中<code>__ceph_open_session - ceph_monc_open_session</code>建立与mon的连接。<code>open_root_dentry - ceph_mdsc_create_request</code>建立与mds的连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">static struct dentry *ceph_mount(struct file_system_type *fs_type,</span><br><span class="line">       int flags, const char *dev_name, void *data)</span><br><span class="line">&#123;</span><br><span class="line">struct super_block *sb;</span><br><span class="line">struct ceph_fs_client *fsc;</span><br><span class="line">struct dentry *res;</span><br><span class="line">int err;</span><br><span class="line">int (*compare_super)(struct super_block *, void *) = ceph_compare_super;</span><br><span class="line">struct ceph_mount_options *fsopt = NULL;</span><br><span class="line">struct ceph_options *opt = NULL;</span><br><span class="line"></span><br><span class="line">dout(&quot;ceph_mount\n&quot;);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CEPH_FS_POSIX_ACL</span><br><span class="line">flags |= MS_POSIXACL;</span><br><span class="line">#endif</span><br><span class="line">err = parse_mount_options(&amp;fsopt, &amp;opt, flags, data, dev_name);</span><br><span class="line">if (err &lt; 0) &#123;</span><br><span class="line">res = ERR_PTR(err);</span><br><span class="line">goto out_final;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* create client (which we may/may not use) */</span><br><span class="line">fsc = create_fs_client(fsopt, opt);</span><br><span class="line">if (IS_ERR(fsc)) &#123;</span><br><span class="line">res = ERR_CAST(fsc);</span><br><span class="line">destroy_mount_options(fsopt);</span><br><span class="line">ceph_destroy_options(opt);</span><br><span class="line">goto out_final;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ceph_mdsc_init(fsc);</span><br><span class="line">if (err &lt; 0) &#123;</span><br><span class="line">res = ERR_PTR(err);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ceph_test_opt(fsc-&gt;client, NOSHARE))</span><br><span class="line">compare_super = NULL;</span><br><span class="line">sb = sget(fs_type, compare_super, ceph_set_super, flags, fsc);</span><br><span class="line">if (IS_ERR(sb)) &#123;</span><br><span class="line">res = ERR_CAST(sb);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ceph_sb_to_client(sb) != fsc) &#123;</span><br><span class="line">ceph_mdsc_destroy(fsc);</span><br><span class="line">destroy_fs_client(fsc);</span><br><span class="line">fsc = ceph_sb_to_client(sb);</span><br><span class="line">dout(&quot;get_sb got existing client %p\n&quot;, fsc);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dout(&quot;get_sb using new client %p\n&quot;, fsc);</span><br><span class="line">err = ceph_register_bdi(sb, fsc);</span><br><span class="line">if (err &lt; 0) &#123;</span><br><span class="line">res = ERR_PTR(err);</span><br><span class="line">goto out_splat;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = ceph_real_mount(fsc);</span><br><span class="line">if (IS_ERR(res))</span><br><span class="line">goto out_splat;</span><br><span class="line">dout(&quot;root %p inode %p ino %llx.%llx\n&quot;, res,</span><br><span class="line">     res-&gt;d_inode, ceph_vinop(res-&gt;d_inode));</span><br><span class="line">return res;</span><br><span class="line"></span><br><span class="line">out_splat:</span><br><span class="line">ceph_mdsc_close_sessions(fsc-&gt;mdsc);</span><br><span class="line">deactivate_locked_super(sb);</span><br><span class="line">goto out_final;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">ceph_mdsc_destroy(fsc);</span><br><span class="line">destroy_fs_client(fsc);</span><br><span class="line">out_final:</span><br><span class="line">dout(&quot;ceph_mount fail %ld\n&quot;, PTR_ERR(res));</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static struct dentry *ceph_real_mount(struct ceph_fs_client *fsc)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">unsigned long started = jiffies;  /* note the start time */</span><br><span class="line">struct dentry *root;</span><br><span class="line"></span><br><span class="line">dout(&quot;mount start %p\n&quot;, fsc);</span><br><span class="line">mutex_lock(&amp;fsc-&gt;client-&gt;mount_mutex);</span><br><span class="line"></span><br><span class="line">if (!fsc-&gt;sb-&gt;s_root) &#123;</span><br><span class="line">const char *path;</span><br><span class="line">err = __ceph_open_session(fsc-&gt;client, started);</span><br><span class="line">if (err &lt; 0)</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line">if (!fsc-&gt;mount_options-&gt;server_path) &#123;</span><br><span class="line">path = &quot;&quot;;</span><br><span class="line">dout(&quot;mount opening path \\t\n&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">path = fsc-&gt;mount_options-&gt;server_path + 1;</span><br><span class="line">dout(&quot;mount opening path %s\n&quot;, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ceph_fs_debugfs_init(fsc);</span><br><span class="line">if (err &lt; 0)</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line">root = open_root_dentry(fsc, path, started);</span><br><span class="line">if (IS_ERR(root)) &#123;</span><br><span class="line">err = PTR_ERR(root);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line">fsc-&gt;sb-&gt;s_root = dget(root);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">root = dget(fsc-&gt;sb-&gt;s_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fsc-&gt;mount_state = CEPH_MOUNT_MOUNTED;</span><br><span class="line">dout(&quot;mount success\n&quot;);</span><br><span class="line">mutex_unlock(&amp;fsc-&gt;client-&gt;mount_mutex);</span><br><span class="line">return root;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;fsc-&gt;client-&gt;mount_mutex);</span><br><span class="line">return ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-返回到用户空间"><a href="#7-返回到用户空间" class="headerlink" title="7. 返回到用户空间"></a>7. 返回到用户空间</h3><p>挂载成功后，sys_mount 返回到用户空间，mount 命令得到返回结果。</p><p>此时，Ceph 文件系统的根目录已经挂载在指定的挂载点，用户可以通过挂载点访问 Ceph 文件系统。</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>在<code>/var/log/messages</code>中只看到这两条相关日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nov xx 11:03:56 node1 kernel: libceph: mon0 192.xxx.xxx.xxx:6789 session established</span><br><span class="line">Nov xx 11:03:56 node1 kernel: libceph: client50981349 fsid ed69ef4c-63ed-436f-a733-c53c0037105d</span><br></pre></td></tr></table></figure><p>以上日志信息远远不够，准备提高内核日志打印级别继续看看。</p><h4 id="内核日志级别调整"><a href="#内核日志级别调整" class="headerlink" title="内核日志级别调整"></a>内核日志级别调整</h4><p>内核日志级别可以通过<code>/proc/sys/kernel/printk</code>文件来修改</p><p>先来看看这个文件初始是什么样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# cat /proc/sys/kernel/printk</span><br><span class="line">4417</span><br></pre></td></tr></table></figure><p>这四个值的定义可以在<code>kernel/printk.c</code>中找到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int console_printk[4] = &#123;</span><br><span class="line">DEFAULT_CONSOLE_LOGLEVEL,/* console_loglevel */</span><br><span class="line">DEFAULT_MESSAGE_LOGLEVEL,/* default_message_loglevel */</span><br><span class="line">MINIMUM_CONSOLE_LOGLEVEL,/* minimum_console_loglevel */</span><br><span class="line">DEFAULT_CONSOLE_LOGLEVEL,/* default_console_loglevel */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而内核日志级别有以下七种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define KERN_EMERGKERN_SOH &quot;0&quot;/* system is unusable */</span><br><span class="line">#define KERN_ALERTKERN_SOH &quot;1&quot;/* action must be taken immediately */</span><br><span class="line">#define KERN_CRITKERN_SOH &quot;2&quot;/* critical conditions */</span><br><span class="line">#define KERN_ERRKERN_SOH &quot;3&quot;/* error conditions */</span><br><span class="line">#define KERN_WARNINGKERN_SOH &quot;4&quot;/* warning conditions */</span><br><span class="line">#define KERN_NOTICEKERN_SOH &quot;5&quot;/* normal but significant condition */</span><br><span class="line">#define KERN_INFOKERN_SOH &quot;6&quot;/* informational */</span><br><span class="line">#define KERN_DEBUGKERN_SOH &quot;7&quot;/* debug-level messages */</span><br><span class="line"></span><br><span class="line">#define KERN_DEFAULTKERN_SOH &quot;d&quot;/* the default kernel loglevel */</span><br></pre></td></tr></table></figure><p>只需要调整对应数字就可以，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo 8 4 1 7 &gt; /proc/sys/kernel/printk</span><br><span class="line">注意：控制台只会显示大于所设置等级的信息，比如想要看debug(7)日志信息，需要设置为7以上</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">确保/etc/rsyslog.conf文件中 #kern.* 注释被取消！</span><br><span class="line">systemctl restart rsyslog</span><br><span class="line">这样内核产生的所有日志信息都会被记录到相应的文件中，包括 dout 产生的调试信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>补充：<br><code>dmesg</code> 的信息在环缓冲区中，只包含最新的内核日志；<br><code>/var/log/messages</code> 是磁盘上的文件，保留较长时间的日志记录。</p></blockquote><h4 id="补充-内核开启DEBUG"><a href="#补充-内核开启DEBUG" class="headerlink" title="补充 - 内核开启DEBUG"></a>补充 - 内核开启DEBUG</h4><p>在生产环境中，出于安全和性能的考虑，可能会禁用调试信息，这时候调整日志打印级别是不生效的，这时候需要在内核代码中打开DEBUG<br><strong>方法一</strong><br>修改Makefile文件，比如我们要打开fs&#x2F;ceph&#x2F;下所有文件及子目录下的DEBUG宏，可以在fs&#x2F;ceph&#x2F;Makefile中添加<code>subdir-ccflags-y := -DDEBUG</code>选项</p><p><strong>方法二</strong><br>在<code>pr_debug/dev_dbg</code>模块最上面加上<code>#define DEBUG</code>语句</p><p>开启之后，在dmesg中就可以看到pr_debug&#x2F;dev_dbg的打印信息了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ceph </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juicefs元数据及数据存储方式</title>
      <link href="/2024/11/01/juicefs%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/11/01/juicefs%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><p>文件系统使用juicefs，元数据存储使用postgresql，数据存储使用minio</p><h5 id="问题？"><a href="#问题？" class="headerlink" title="问题？"></a>问题？</h5><p>通过juicefs写入一个文件，元数据在postgresql中是如何存储的？数据在minio中又是如何存储的？</p><p>新建 <code>file1、dir1/file1、dir1/file2</code>三个文件，大小分别为<code>4B 9B 13B</code></p><h5 id="在postgresql中"><a href="#在postgresql中" class="headerlink" title="在postgresql中"></a>在postgresql中</h5><p><code>jfs_node</code>表中记录着文件元数据信息</p><p><img src="/../images/juicefs_meta/jfs_node.png" alt="image"></p><p><code>jfs_chunk</code>表中记录着文件分片信息</p><p><img src="/../images/juicefs_meta/jfs_chunk.png" alt="image"></p><p>slices中可以看到存着一堆16进制代码，看看juicefs源码里slices的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Slice struct &#123;</span><br><span class="line">    Pos  uint32 // offset of the Slice in the Chunk</span><br><span class="line">    ID   uint64 // ID of the Slice, globally unique</span><br><span class="line">    Size uint32 // size of the Slice</span><br><span class="line">    Off  uint32 // offset of valid data in this Slice</span><br><span class="line">    Len  uint32 // size of valid data in this Slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在二进制存储中，每2个十六进制字符代表1个字节</p><p>以slices <code>\x0000000000000000000000040000000d000000000000000d</code>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000          Slice 在 Chunk 中的偏移位置为0</span><br><span class="line">0000000000000004  Slice 的 ID，全局唯一（chunkid）转换为10进制数为4,</span><br><span class="line">0000000d          slice 的总大小为13</span><br><span class="line">00000000          有效数据在此 Slice 中的偏移位置</span><br><span class="line">0000000d          有效数据在此 Slice 中的大小为13</span><br></pre></td></tr></table></figure><p>由上可解析出slice的各部分信息，跟以下chunk_ref表中的数据也能够一一对应</p><p><code>jfs_chunk_ref</code>表中记录着文件分片补充信息</p><p><img src="/../images/juicefs_meta/jfs_chunk_ref.png" alt="image"></p><h5 id="在minio中"><a href="#在minio中" class="headerlink" title="在minio中"></a>在minio中</h5><p>可以看到具体的数据已经按照一定的层级存储到了minio中</p><p><img src="/../images/juicefs_meta/minio.png" alt="image"></p><blockquote><p>目录层级关系和名字看着很陌生，是以什么规则进行的呢？层级中的<code>chunks/0/0/</code>是怎么来的？对象名字<code>4_0_13</code>是怎么来的？</p></blockquote><p>查看源码得知，在<code>juicefs/pkg/chunk/cached_store.go</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (s *rSlice) key(indx int) string &#123;</span><br><span class="line">if s.store.conf.HashPrefix &#123;</span><br><span class="line">return fmt.Sprintf(&quot;chunks/%02X/%v/%v_%v_%v&quot;, s.id%256, s.id/1000/1000, s.id, indx, s.blockSize(indx))</span><br><span class="line">&#125;</span><br><span class="line">return fmt.Sprintf(&quot;chunks/%v/%v/%v_%v_%v&quot;, s.id/1000/1000, s.id/1000, s.id, indx, s.blockSize(indx))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入一个index字段，最终生成一个字符串类型的路径，HashPrefix是一个配置项，以chunk表中id为3的数据为例，slice解析后的id为4，index为0，所以会返回<code>chunks/0/0/,4_0_13</code>，也能够跟minio中的数据一一对应</p><p>至此已基本了解文件到对象的元数据集数据的存储方式</p>]]></content>
      
      
      
        <tags>
            
            <tag> Juicefs </tag>
            
            <tag> Minio </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go test</title>
      <link href="/2024/09/24/go-test/"/>
      <url>/2024/09/24/go-test/</url>
      
        <content type="html"><![CDATA[<p><code>go test</code> 是 Go 语言的内置工具，用于自动化测试 Go 代码。</p><h3 id="1、测试文件结构"><a href="#1、测试文件结构" class="headerlink" title="1、测试文件结构"></a>1、测试文件结构</h3><ul><li><p><code>测试文件名</code>必须以 _test.go 结尾。例如：example_test.go。</p></li><li><p><code>测试函数名称</code>必须以 Test 开头，参数类型为 *testing.T</p></li></ul><h3 id="2、测试命令"><a href="#2、测试命令" class="headerlink" title="2、测试命令"></a>2、测试命令</h3><blockquote><p>在当前目录运行所有测试<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure><br>运行特定的测试函数<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -run Testfunc</span><br></pre></td></tr></table></figure><br>查看代码覆盖率<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -cover</span><br></pre></td></tr></table></figure><br>生成详细的测试覆盖率报告<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go test -coverprofile=coverage.out</span><br><span class="line">go tool cover -func=coverage.out</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="3、额外测试"><a href="#3、额外测试" class="headerlink" title="3、额外测试"></a>3、额外测试</h3><blockquote><p>基准测试</p></blockquote><p>基准测试函数以 Benchmark 开头，参数类型为 *testing.B </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=.</span><br></pre></td></tr></table></figure><blockquote><p>并发测试</p></blockquote><p>使用 Go 的 t.Parallel() 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line">    result := Add(1, 2)</span><br><span class="line">    if result != 3 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(1, 2) = %d; want 3&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、其他常用标志"><a href="#4、其他常用标志" class="headerlink" title="4、其他常用标志"></a>4、其他常用标志</h3><blockquote><p>-timeout：设置测试的超时时间。例如，-timeout 30s。</p></blockquote><blockquote><p>-coverpkg：计算多个包的覆盖率。</p></blockquote><blockquote><p>-short：运行短测试，跳过长时间运行的测试。</p></blockquote><blockquote><p>-json：以 JSON 格式输出测试结果。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JuiceFS元数据引擎PostgreSQL</title>
      <link href="/2024/08/27/JuiceFS%E5%85%83%E6%95%B0%E6%8D%AE%E5%BC%95%E6%93%8EPostgreSQL/"/>
      <url>/2024/08/27/JuiceFS%E5%85%83%E6%95%B0%E6%8D%AE%E5%BC%95%E6%93%8EPostgreSQL/</url>
      
        <content type="html"><![CDATA[<p>使用PostgreSQL作为JuiceFS元数据引擎，各表的含义和字段做一个简单归纳</p><blockquote><p>juicefs数据库用于存储juicefs文件信息</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=# \l</span><br><span class="line">                                                      List of databases</span><br><span class="line">   Name    |  Owner   | Encoding | Locale Provider |  Collate   |   Ctype    | ICU Locale | ICU Rules |   Access privileges</span><br><span class="line">-----------+----------+----------+-----------------+------------+------------+------------+-----------+-----------------------</span><br><span class="line"> juicefs   | juicefs  | UTF8     | libc            | en_US.utf8 | en_US.utf8 |            |           |</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以看到数据库包含了很多张表</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">juicefs=# \dt</span><br><span class="line">              List of relations</span><br><span class="line"> Schema |       Name        | Type  |  Owner</span><br><span class="line">--------+-------------------+-------+---------</span><br><span class="line"> public | jfs_acl           | table | juicefs</span><br><span class="line"> public | jfs_chunk         | table | juicefs</span><br><span class="line"> public | jfs_chunk_ref     | table | juicefs</span><br><span class="line"> public | jfs_counter       | table | juicefs</span><br><span class="line"> public | jfs_delfile       | table | juicefs</span><br><span class="line"> public | jfs_delslices     | table | juicefs</span><br><span class="line"> public | jfs_detached_node | table | juicefs</span><br><span class="line"> public | jfs_dir_quota     | table | juicefs</span><br><span class="line"> public | jfs_dir_stats     | table | juicefs</span><br><span class="line"> public | jfs_edge          | table | juicefs</span><br><span class="line"> public | jfs_flock         | table | juicefs</span><br><span class="line"> public | jfs_node          | table | juicefs</span><br><span class="line"> public | jfs_plock         | table | juicefs</span><br><span class="line"> public | jfs_session2      | table | juicefs</span><br><span class="line"> public | jfs_setting       | table | juicefs</span><br><span class="line"> public | jfs_sustained     | table | juicefs</span><br><span class="line"> public | jfs_symlink       | table | juicefs</span><br><span class="line"> public | jfs_xattr         | table | juicefs</span><br><span class="line">(18 rows)</span><br></pre></td></tr></table></figure><ul><li><p><strong>jfs_setting       存储文件系统格式化信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  name  |                                                    value</span><br><span class="line">--------+--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> format | &#123;                                                                                                           +</span><br><span class="line">        | &quot;Name&quot;: &quot;juicefs&quot;,                                                                                          +</span><br><span class="line">        | &quot;UUID&quot;: &quot;6b1aaa0a-e3da-43db-ab4e-252a92f722bd&quot;,                                                             +</span><br><span class="line">        | &quot;Storage&quot;: &quot;s3&quot;,                                                                                            +</span><br><span class="line">        | &quot;Bucket&quot;: &quot;http://192.168.247.143:9000/bucket1&quot;,                                                            +</span><br><span class="line">        | &quot;AccessKey&quot;: &quot;jAzkO6aquJlH8daWJ0vC&quot;,                                                                        +</span><br><span class="line">        | &quot;SecretKey&quot;: &quot;UclQZeuePQcp9HmMd9Q0EUkL0QIb70ty9kPbbWRcpaYI0JjAUUsE6x8dZ4QxU3hLsK1EbesYB4DfJHeJzPzHUL+ch5A=&quot;,+</span><br><span class="line">        | &quot;BlockSize&quot;: 4096,                                                                                          +</span><br><span class="line">        | &quot;Compression&quot;: &quot;none&quot;,                                                                                      +</span><br><span class="line">        | &quot;EncryptAlgo&quot;: &quot;aes256gcm-rsa&quot;,                                                                             +</span><br><span class="line">        | &quot;KeyEncrypted&quot;: true,                                                                                       +</span><br><span class="line">        | &quot;TrashDays&quot;: 1,                                                                                             +</span><br><span class="line">        | &quot;MetaVersion&quot;: 1,                                                                                           +</span><br><span class="line">        | &quot;MinClientVersion&quot;: &quot;1.1.0-A&quot;,                                                                              +</span><br><span class="line">        | &quot;DirStats&quot;: true,                                                                                           +</span><br><span class="line">        | &quot;EnableACL&quot;: false                                                                                          +</span><br><span class="line">        | &#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_edge     存储文件名、inode号及父目录inode号信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> id | parent |     name     | inode | type</span><br><span class="line">----+--------+--------------+-------+------</span><br><span class="line">  1 |      1 | \x64697231   |     2 |    2</span><br><span class="line">  2 |      1 | \x66696c6531 |     3 |    1</span><br><span class="line">  3 |      2 | \x66696c6531 |     4 |    1</span><br><span class="line">  4 |      2 | \x66696c6532 |     5 |    1</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_node      存储文件系统的基本元数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        inode        | type | flags | mode | uid | gid |      atime       |      mtime       |      ctime       | atimensec | mtimensec | ctimensec | nlink | length | rdev | parent | access_acl_id | default_acl_id</span><br><span class="line">---------------------+------+-------+------+-----+-----+------------------+------------------+------------------+-----------+-----------+-----------+-------+--------+------+--------+---------------+----------------</span><br><span class="line"> 9223372032828243968 |    2 |     0 |  365 |   0 |   0 | 1720746821874411 | 1720746821874411 | 1720746821874411 |       855 |       855 |       855 |     2 |   4096 |    0 |      1 |             0 |              0</span><br><span class="line">                   1 |    2 |     0 |  511 |   0 |   0 | 1720746821874411 | 1720751372873926 | 1720751372873926 |       855 |       855 |       855 |     3 |   4096 |    0 |      1 |             0 |              0</span><br><span class="line">                   3 |    1 |     0 |  420 |   0 |   0 | 1720751372873926 | 1720751372878651 | 1720751372885031 |        42 |        11 |       201 |     1 |      4 |    0 |      1 |             0 |              0</span><br><span class="line">                   4 |    1 |     0 |  420 |   0 |   0 | 1720751407595564 | 1720751407598082 | 1720751407603477 |       450 |       178 |       346 |     1 |      9 |    0 |      2 |             0 |              0</span><br><span class="line">                   2 |    2 |     0 |  493 |   0 |   0 | 1720750221908578 | 1720751416940112 | 1720751416940112 |       916 |       916 |       916 |     2 |   4096 |    0 |      1 |             0 |              0</span><br><span class="line">                   5 |    1 |     0 |  420 |   0 |   0 | 1720751416940112 | 1720751416942616 | 1720751416946878 |       475 |       471 |       682 |     1 |     13 |    0 |      2 |             0 |              0</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_chunk    存储文件的块信息，slices分段记录着信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> id | inode | indx |                       slices</span><br><span class="line">----+-------+------+----------------------------------------------------</span><br><span class="line">  1 |     3 |    0 | \x000000000000000000000001000000040000000000000004</span><br><span class="line">  2 |     4 |    0 | \x000000000000000000000003000000090000000000000009</span><br><span class="line">  3 |     5 |    0 | \x0000000000000000000000040000000d000000000000000d</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_chunk_ref   chunkid与size可组成对象名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> chunkid | size | refs</span><br><span class="line">---------+------+------</span><br><span class="line">       1 |    4 |    1</span><br><span class="line">       3 |    9 |    1</span><br><span class="line">       4 |   13 |    1</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_counter     存储文件系统汇总计数信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        name         |   value</span><br><span class="line">---------------------+------------</span><br><span class="line"> nextSession         |          5</span><br><span class="line"> nextChunk           |       4097</span><br><span class="line"> usedSpace           |      16384</span><br><span class="line"> totalInodes         |          4</span><br><span class="line"> lastCleanupFiles    | 1722842479</span><br><span class="line"> lastCleanupSessions | 1722842515</span><br><span class="line"> nextCleanupSlices   | 1722840923</span><br><span class="line"> lastCleanupTrash    | 1722840440</span><br><span class="line"> nextInode           |       1026</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_dir_stats     存储着各目录状态信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> inode | data_length | used_space | used_inodes</span><br><span class="line">-------+-------------+------------+-------------</span><br><span class="line">     1 |           4 |       8192 |           2</span><br><span class="line">     2 |          22 |       8192 |           2</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_symlink   存储符号链接的信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> inode | target</span><br><span class="line">-------+--------</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_xattr     存储扩展属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> id | inode |    name    |                   value</span><br><span class="line">----+-------+------------+--------------------------------------------</span><br><span class="line">  1 |     1 | lastBackup | \x323032342d30382d30355430363a30383a34335a</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_session2   存储客户端会话信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> sid |   expire   |                    info</span><br><span class="line">-----+------------+-------------------------------------------------------------</span><br><span class="line">   5 | 1722841562 | \x7b2256657273696f6e223a22312e322e302b323032342d</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_plock   存储文件锁的信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> id | inode | sid | owner | records</span><br><span class="line">----+-------+-----+-------+---------</span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_delfile      存储删除文件信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> inode | length | expire</span><br><span class="line">-------+--------+--------</span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_dir_quota      存储配额信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> inode | max_space | max_inodes | used_space | used_inodes</span><br><span class="line">-------+-----------+------------+------------+-------------</span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用nginx代理，实现扫描二维码查看静态网页功能</title>
      <link href="/2024/08/27/%E4%BD%BF%E7%94%A8nginx%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%9F%A5%E7%9C%8B%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%8A%9F%E8%83%BD/"/>
      <url>/2024/08/27/%E4%BD%BF%E7%94%A8nginx%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%9F%A5%E7%9C%8B%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="1、创建项目目录"><a href="#1、创建项目目录" class="headerlink" title="1、创建项目目录"></a>1、创建项目目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-image-page</span><br><span class="line">cd my-image-page</span><br></pre></td></tr></table></figure><h3 id="2、准备图片和HTML文件"><a href="#2、准备图片和HTML文件" class="headerlink" title="2、准备图片和HTML文件"></a>2、准备图片和HTML文件</h3><ul><li><p>上传图片：将 image.jpg 上传到 my-image-page 目录。</p></li><li><p>创建HTML文件：在同一目录下创建一个 index.html 文件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Image Display&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;image.jpg&quot; alt=&quot;Display Image&quot; style=&quot;width:100%; height:auto;&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="3、创建-Dockerfile"><a href="#3、创建-Dockerfile" class="headerlink" title="3、创建 Dockerfile"></a>3、创建 Dockerfile</h3><p>在 my-image-page 目录下创建一个 Dockerfile 文件，用于定义容器环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Nginx image as the base image</span><br><span class="line"># 此处若无法直接拉取镜像，可尝试使用代理 FROM docker.fxxk.dedyn.io/nginx:latest</span><br><span class="line">FROM nginx:latest</span><br><span class="line"></span><br><span class="line"># Copy the HTML and image files into the Nginx web directory</span><br><span class="line"># 拷贝服务器文件到镜像内 docker cp &lt;源文件路径&gt; &lt;容器名称&gt;:&lt;容器内路径&gt;</span><br><span class="line">COPY . /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line"># Expose port 80</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><h3 id="4、构建Docker镜像"><a href="#4、构建Docker镜像" class="headerlink" title="4、构建Docker镜像"></a>4、构建Docker镜像</h3><p>在项目目录 my-image-page 中，运行以下命令来构建Docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-image-page .</span><br></pre></td></tr></table></figure><p>这条命令会根据 Dockerfile 的内容创建一个名为 my-image-page 的Docker镜像。</p><h3 id="5、运行Docker容器"><a href="#5、运行Docker容器" class="headerlink" title="5、运行Docker容器"></a>5、运行Docker容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name my-image-container my-image-page</span><br></pre></td></tr></table></figure><ul><li><strong>-d</strong>：后台运行容器。</li><li><strong>-p 80:80</strong>：将容器的80端口映射到主机的80端口。</li><li><strong>–name my-image-container</strong>：为容器指定一个名字。</li></ul><h3 id="6、访问页面"><a href="#6、访问页面" class="headerlink" title="6、访问页面"></a>6、访问页面</h3><ul><li>获取服务器IP：确保云服务器的防火墙允许访问80端口。</li><li>访问静态页面：通过浏览器访问 <code>http://your-server-ip/</code> 或 <code>http://your-domain.com/</code>，应该能看到包含图片的静态页面。、</li></ul><h3 id="7、生成二维码"><a href="#7、生成二维码" class="headerlink" title="7、生成二维码"></a>7、生成二维码</h3><p>使用网站 <a href="https://www.qr-code-generator.com/">https://www.qr-code-generator.com/</a> 生成一个二维码，内容为 <code>http://your-server-ip/</code> 或 <code>http://your-domain.com/</code></p><h3 id="8、管理和更新"><a href="#8、管理和更新" class="headerlink" title="8、管理和更新"></a>8、管理和更新</h3><ul><li>查看运行中的容器：使用 <code>docker ps</code> 可以查看正在运行的容器。</li><li>停止容器：使用 <code>docker stop my-image-container</code> 可以停止容器。</li><li>删除容器：使用 <code>docker rm my-image-container</code> 可以删除容器。</li><li>更新内容：如果需要更新图片或HTML文件，修改文件后重新构建镜像，并运行新容器。</li></ul><p>这样，通过Docker，你可以轻松地将这个静态页面部署在容器中，并方便地进行管理和更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识和使用JuiceFS</title>
      <link href="/2024/06/13/%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BD%BF%E7%94%A8JuiceFS/"/>
      <url>/2024/06/13/%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BD%BF%E7%94%A8JuiceFS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>认识和使用minio</title>
      <link href="/2024/06/13/%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BD%BF%E7%94%A8minio/"/>
      <url>/2024/06/13/%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BD%BF%E7%94%A8minio/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是minio"><a href="#什么是minio" class="headerlink" title="什么是minio?"></a>什么是minio?</h3><p>minio 是一个基于Apache License v2.0开源协议的轻量对象存储服务，兼容亚马逊S3接口，号称目前速度最快，在标准硬件上，对象存储的读&#x2F;写速度最高可以高达183 GB&#x2F;s和171 GB&#x2F;s。</p><p>官网文档地址：<a href="https://docs.min.io/cn/">https://docs.min.io/cn/</a></p><h3 id="部署使用minio服务端"><a href="#部署使用minio服务端" class="headerlink" title="部署使用minio服务端"></a>部署使用minio服务端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#下载Minio服务器二进制文件</span><br><span class="line">wget https://dl.min.io/server/minio/release/linux-amd64/minio</span><br><span class="line">chmod +x minio</span><br><span class="line">mv minio /usr/local/bin/</span><br><span class="line">#创建存储目录</span><br><span class="line">mkdir /mnt/data</span><br><span class="line"></span><br><span class="line">#运行Minio服务器</span><br><span class="line">./minio server /mnt/data</span><br></pre></td></tr></table></figure><p>本次部署使用的服务器<code>内核版本为3.10.x.x</code>，开启服务后提示如下<code>信息及警告</code>：</p><p><img src="/../images/minio/minio_server.png" alt="image"></p><p>此时可以访问ui页面<code>http://127.0.0.1:9000</code>进行一些简单操作了！</p><p><img src="/../images/minio/minio_ui.png" alt="image"></p><h3 id="部署使用minio客户端"><a href="#部署使用minio客户端" class="headerlink" title="部署使用minio客户端"></a>部署使用minio客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#下载Minio客户端二进制文件</span><br><span class="line">wget https://dl.min.io/client/mc/release/linux-amd64/mc</span><br><span class="line">chmod +x mc</span><br><span class="line">mv mc /usr/local/bin/</span><br><span class="line"></span><br><span class="line">#配置Minio客户端</span><br><span class="line">mc alias set &#x27;myminio&#x27; &#x27;http://192.168.247.141:9000&#x27; &#x27;minioadmin&#x27; &#x27;minioadmin&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建存储桶</span><br><span class="line">mc mb myminio/mybucket</span><br><span class="line"></span><br><span class="line">#上传文件</span><br><span class="line">mc cp /path/to/localfile myminio/mybucket</span><br><span class="line"></span><br><span class="line">#列出存储桶中的文件</span><br><span class="line">mc ls myminio/mybucket</span><br><span class="line"></span><br><span class="line"># 下载文件</span><br><span class="line">mc cp myminio/mybucket/remote-file /path/to/localdir</span><br><span class="line"></span><br><span class="line"># 删除文件</span><br><span class="line">mc rm myminio/mybucket/remote-file</span><br></pre></td></tr></table></figure><p>至此可以初步认识和操作minio了，未完待续！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Minio </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prometheus + grafana 监测ceph集群状态</title>
      <link href="/2024/05/22/prometheus-grafana-%E7%9B%91%E6%B5%8Bceph%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81/"/>
      <url>/2024/05/22/prometheus-grafana-%E7%9B%91%E6%B5%8Bceph%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h5 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h5><p>最近在使用海量小文件压测ceph集群，<strong>想要一个可视化的界面来方便监测ceph集群状态</strong>，由于很久之前使用过prometheus + grafana 监测 k8s 集群状态，想着用来监测 ceph 集群应该问题不大，那么就开始吧！</p><p>首先了解下 <strong>prometheus 和 grafana 是什么</strong>？<br>通俗来讲，<strong>Prometheus可以通过各种方式采集应用程序和系统的指标数据</strong>，例如服务器的 CPU 使用率、内存使用率、网络流量等等。采集到的数据会存储在一个时间序列数据库中，用户可以使用PromQL查询语言进行查询和分析。同时，Prometheus还提供了告警机制，可以在监控数据超出设定的阈值时发出告警通知。而<strong>Grafana可以通过连接Prometheus数据源，将采集到的数据进行可视化展示</strong>，例如将 CPU 使用率和内存使用率用折线图的形式展示出来。用户可以通过配置仪表盘来自定义展示的数据和样式，以及添加告警规则和面板等。</p><p><strong>Prometheus + Grafana组合就是一套监控和可视化解决方案，可以帮助用户更好地监控和管理他们的应用程序、服务器和网络设备。</strong></p><p>在 Ceph Luminous (12.x) 之前的版本，可以使用第三方的 ceph_exporter 采集 Ceph 集群的监控信息。 从 Ceph Luminous 12.2.1 版本开始，MGR 中自带了 Prometheus 插件，内置了 Prometheus Ceph Exporter，可以使用 Ceph MGR 内置的 exporter 作为 Prometheus 的 target。</p><h4 id="一、启用-ceph-prometheus-模块"><a href="#一、启用-ceph-prometheus-模块" class="headerlink" title="一、启用 ceph prometheus 模块"></a>一、启用 ceph prometheus 模块</h4><p>任意一台ceph mgr节点执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph mgr module enable prometheus</span><br></pre></td></tr></table></figure><p>启用成功后可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# ceph mgr services</span><br><span class="line">&#123;</span><br><span class="line">    &quot;dashboard&quot;: &quot;https://node1:8443/&quot;,</span><br><span class="line">    &quot;prometheus&quot;: &quot;http://node1:9283/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 9283 是 ceph_exporter 的默认监听端口，访问 <code>http://&lt;MGR&gt;:9283/metrics</code> 可以获取到 metrics</p><p><img src="/../images/ui_1.png" alt="prometheus"></p><h4 id="二、安装-prometheus-server"><a href="#二、安装-prometheus-server" class="headerlink" title="二、安装 prometheus server"></a>二、安装 prometheus server</h4><h5 id="1、二进制安装"><a href="#1、二进制安装" class="headerlink" title="1、二进制安装"></a>1、二进制安装</h5><p>Prometheus 基于 Golang 编写，编译后的软件包，不依赖于任何的第三方依赖。所以只需要下载对应平台的二进制包，解压并且添加基本的配置即可正常启动 Prometheus Server。</p><p>下载地址：<a href="https://prometheus.io/download/">https://prometheus.io/download/</a></p><p>解压并且移动到 &#x2F;opt&#x2F; 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# tar zxvf prometheus-2.45.0.linux-amd64.tar.gz</span><br><span class="line">[root@node1 ~]# mv prometheus-2.45.0.linux-amd64 /opt/prometheus/</span><br><span class="line">[root@node1 ~]# cd /opt/prometheus/</span><br></pre></td></tr></table></figure><h5 id="2、将-prometheus-配置为系统服务进行管理"><a href="#2、将-prometheus-配置为系统服务进行管理" class="headerlink" title="2、将 prometheus 配置为系统服务进行管理"></a>2、将 prometheus 配置为系统服务进行管理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/prometheus.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=prometheus</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/prometheus/prometheus --config.file=/opt/prometheus/prometheus.yml --storage.tsdb.path=/opt/prometheus/data/ --web.enable-lifecycle</span><br><span class="line">ExecReload=/bin/kill -HUP \$MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h5 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start prometheus</span><br><span class="line">systemctl enable prometheus</span><br></pre></td></tr></table></figure><p>出现关键信息<code>Server is ready to receive web requests.</code> 则启动成功，此时可以通过 <code>http://&lt;IP&gt;:9090</code> 访问 Prometheus 的 UI 界面</p><p><img src="/../images/ui_2.png" alt="image"></p><h5 id="4、配置-prometheus-数据源"><a href="#4、配置-prometheus-数据源" class="headerlink" title="4、配置 prometheus 数据源"></a>4、配置 prometheus 数据源</h5><p>为了让 Prometheus Server 能够从 Ceph Exporter 获取到监控数据，需要修改 Prometheus 配置文件。编辑 prometheus.yml 并在 scrape_configs 节点下添加以下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# vim /opt/prometheus/prometheus.yml</span><br><span class="line">...</span><br><span class="line">  - job_name: &quot;Ceph&quot;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;&lt;IP&gt;:9283&quot;]</span><br></pre></td></tr></table></figure><p>重新加载 <code>systemctl reload prometheus</code>,再次访问 <code>http://&lt;IP&gt;:9090</code>，选择<code>Status -&gt; Targets</code>，此时可以成功获取到 prometheus 数据源</p><p><img src="/../images/ui_3.png" alt="image"></p><h4 id="三、安装-grafana"><a href="#三、安装-grafana" class="headerlink" title="三、安装 grafana"></a>三、安装 grafana</h4><h5 id="1、二进制安装-1"><a href="#1、二进制安装-1" class="headerlink" title="1、二进制安装"></a>1、二进制安装</h5><p>下载地址：<a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# tar zxvf grafana-enterprise-8.0.5.linux-amd64.tar.gz</span><br><span class="line">[root@node1 ~]# mv grafana-8.0.5/ /opt/grafana/</span><br><span class="line">[root@node1 ~]# cd /opt/grafana/</span><br></pre></td></tr></table></figure><h4 id="2、将-grafana-配置为系统服务进行管理"><a href="#2、将-grafana-配置为系统服务进行管理" class="headerlink" title="2、将 grafana 配置为系统服务进行管理"></a>2、将 grafana 配置为系统服务进行管理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/grafana.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=grafana</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/grafana/bin/grafana-server -homepath=/opt/grafana</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h5 id="3、启动-grafana-服务"><a href="#3、启动-grafana-服务" class="headerlink" title="3、启动 grafana 服务"></a>3、启动 grafana 服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start grafana</span><br><span class="line">systemctl enable grafana</span><br></pre></td></tr></table></figure><p>启动成功后可通过<code>http://&lt;IP&gt;:3000</code> 进入到 Grafana UI，默认情况下使用账户 admin&#x2F;admin 进行登录（首次登录会要求修改默认密码）。点击 “Add your first data source” 添加数据源</p><p><img src="/../images/ui_4.png" alt="image"></p><p>选择 “Prometheus”，点击右侧的 “Select”</p><p><img src="/../images/ui_5.png" alt="image"></p><p>“URL” 填写 Prometheus 的访问地址，滑到最下方点击 “Save &amp; test” 完成添加，配置正确的情况下会提示 “Data source is working” 的信息。</p><p>完成数据源的添加之后就可以在 Grafana 中创建可视化 Dashboard 了，选择左侧 <code>Dashboards -&gt; Manage</code>，点击 <code>Import</code>,输入 Dashboard 模板编号 2842，点击 <code>Load</code>,给 Dashboard 配置个名称，选择数据源为 <code>Prometheus</code>，最后点击 <code>Import</code></p><p><img src="/../images/ui_6.png" alt="image"></p><h4 id="部署中遇到的几个小问题："><a href="#部署中遇到的几个小问题：" class="headerlink" title="部署中遇到的几个小问题："></a>部署中遇到的几个小问题：</h4><p>1、由于服务器是局域网，时间服务器设置问题，导致 prometheus 对接数据源的时候会有警告<code>Warning: Error fetching server time: Detected 229.88299989700317 seconds time difference between your browser and the server. Prometheus relies on accurate time and time drift might cause unexpected query results.</code></p><p>先选择了笨办法手动改一下时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2023-06-28 11:41:00&quot;</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><p>2、添加 dashboard 模板时，输入模板编号提示<code>Bad Gateway</code>,此时可以去<a href="https://grafana.com/grafana/dashboards/">grafana dashboards官网</a>自行下载json文件然后<code>Upload JSON file</code><br><img src="/../images/ui_7.png" alt="image"></p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>文章主要参考自 <a href="https://www.koenli.com/af5b9d4e.html">使用 Prometheus+Grafana 监控 Ceph</a>，在此基础上根据自身环境所撰写，如有侵权请联系删除！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络流量问题排查-UDP丢包</title>
      <link href="/2024/05/22/Linux%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-UDP%E4%B8%A2%E5%8C%85/"/>
      <url>/2024/05/22/Linux%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-UDP%E4%B8%A2%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><em>一直以来对Linux网络这部分了解比较少，解决问题总是没有条理</em></p><p><strong>问题：</strong>遇到一个<strong>UDP丢包</strong>的问题：在测试中，一台VM虚拟机，CPU利用率55%左右，内存利用率7%左右，网卡流量也远没到限制的时候出现了丢包情况**</p><p><strong>验证：</strong><code>netstat -su|grep &quot;packet receive errors&quot;|awk &#39;&#123;print $1&#125;&#39;</code>  ，每30s查看一次，计算这次和上次之间的数值差值发现存在UDP丢包现象。</p><p>首先要看问题出现在哪儿，网络流量的路径是怎样的？</p><blockquote><p>1、网络流量通过有线&#x2F;无线发送到网卡<br>2、网卡驱动读取报文放到ring buffer（此时调用DMA，不经过CPU）<br>3、内核从ring buffer中读取报文进行处理，执行IP层，TCP&#x2F;UDP层逻辑<br>4、把报文发到用户态的socket buffer中，应用程序读取socket buffer并进行处理</p></blockquote><p>可能出现问题的地方：1、网卡处理时丢包   2、内核处理时丢包   3、应用程序处理时</p><blockquote><p>1、网卡阶段：</p></blockquote><p>两种方法：</p><p>(1).  <code>ifconfig</code> 查看 <strong>RX errors dropped</strong></p><p>(2).  <code>ethtool -S eth0 |egrep &quot;err|drop&quot;</code></p><p>如果存在丢包，可以查看网卡的ring buffer size是否设置太小达到瓶颈，使用<code>ethtool -g eth0</code>查看最大值和当前值，使用<code>ethtool -G eth0 rx 1024</code>进行修改</p><p>如果网卡方面没问题，那么尝试内核方面查看</p><blockquote><p>2、内核阶段</p></blockquote><p>linux 系统在接收报文之后，会把报文保存到缓存区中。因为缓存区的大小是有限的，如果出现 UDP 报文过大(超过缓存区大小或者 MTU 大小)、接收到报文的速率太快，都可能导致 linux 因为缓存满而直接丢包的情况。</p><p>使用<code>sysctl -a |grep net.core</code>查看相关参数设置</p><p>重点看这几个参数：</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_max</strong>：允许设置的 receive buffer 最大值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_default</strong>：默认使用的 receive buffer 值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_max</strong>：允许设置的 send buffer 最大值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_dafault</strong>：默认使用的 send buffer 最大值</p><p>但是这些初始值并不是为了应对大流量的 UDP 报文，如果应用程序接收和发送 UDP 报文非常多，把这个值调大。</p><p>如果发现某些参数设置不合理需要修改的话：</p><p><strong>方法一</strong>：使用 sysctl 命令让它立即生效</p><p>接收最大值设置 sysctl -w net.core.rmem_max&#x3D;56214400 # 设置为 50M</p><p>接收默认值设置 sysctl -w net.core.rmem_default&#x3D;26214400 # 设置为 25M</p><p>发送最大值 sysctl -w net.core.wmem_max&#x3D;26214400 # 设置为 25M</p><p>发送默认值 sysctl -w net.core.wmem_default&#x3D;26214400 # 设置为 25M</p><p><strong>方法二</strong>：修改对应路径文件的参数或者修改 &#x2F;etc&#x2F;sysctl.conf 中对应的参数在下次启动时让参数保持生效（sysctl -p  生效）</p><blockquote><p>3、应用阶段</p></blockquote><p>系统的 UDP buffer size，调节的 sysctl 参数只是系统允许的最大值，每个应用程序在创建 socket 时需要设置自己 socket buffer size 的值。linux 系统会把接受到的报文放到 socket 的 buffer 中，应用程序从 buffer 中不断地读取报文。</p><p>另外一个因素是应用读取 buffer 中报文的速度，对于应用程序来说，处理报文应该采取异步的方式。</p><p>其他可能原因：</p><p>检查防火墙状态 <code>systemctl status firewalld</code>，或者 <code>iptables</code> 阻断了部分流量？</p><p>要处理的实际业务中，每一个连接会占用一个句柄，测试有反馈有 <em>“Too many open files”</em> 的错误。这可能导致数据丢失而没有正确执行实际业务。</p><p>陆续学习和更新</p><p><a href="https://blog.csdn.net/weixin_40754332/article/details/106924810">参考链接：数据传输过程中丢包分析处理</a></p><p>此外补充下小工具的使用</p><ul><li>netstat   主要是用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字。</li></ul><p><strong>-a</strong>      显示所有连接</p><p><strong>-t</strong>      TCP连接</p><p><strong>-u</strong>      UDP连接</p><p><strong>-l</strong>       列出所有处于监听状态的 Sockets</p><p><strong>-s</strong>      显示所有端口的统计信息，可配合-u&#x2F;-t使用</p><p><strong>Recv-Q</strong> 表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走</p><p><strong>send-Q</strong> 表示本地待发送的数据</p><p>这两个值通常应该为0，如果不为0可能是有问题的。packets在两个队列里都不应该有堆积状态。可接受短暂的非0情况。</p><p><a href="https://blog.csdn.net/wangquan1992/article/details/109508822">参考链接：netstat 命令详解及实现原理</a></p><ul><li>ethtool</li></ul><p><strong>ethtool eth0</strong>       显示网卡状态等信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ohh</title>
      <link href="/2024/05/22/ohh/"/>
      <url>/2024/05/22/ohh/</url>
      
        <content type="html"><![CDATA[<p>重新开始吧~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
