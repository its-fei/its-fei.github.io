<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于juicefs删除文件后仍然存在残留临时文件解决</title>
      <link href="/2025/02/20/juicefs-gc/"/>
      <url>/2025/02/20/juicefs-gc/</url>
      
        <content type="html"><![CDATA[<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>juicefs 使用 postgresql 作为元数据引擎，minio 作为对象存储，当从 juicefs 一侧删除文件之后，发现 pg 中仍然存在很多元数据信息，解析 <code>jfs_edge</code>中的文件名之后发现都是一些<code>swp</code>残留文件，去 minio 中查看也确实都存在</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><h5 id="1、回收站功能："><a href="#1、回收站功能：" class="headerlink" title="1、回收站功能："></a>1、回收站功能：</h5><p>JuiceFS 默认启用了回收站功能，被删除的文件会被移入回收站，而不是立即从对象存储中删除。因此，即使在文件系统中删除了文件，回收站中的文件仍然存在，且仍会被 PostgreSQL 记录。要彻底删除文件，需要清空回收站。</p><h5 id="2、异步删除："><a href="#2、异步删除：" class="headerlink" title="2、异步删除："></a>2、异步删除：</h5><p>JuiceFS 的删除操作是异步的，文件删除请求会被提交到后台任务，实际删除可能会有延迟。因此，删除操作可能尚未完成，导致 PostgreSQL 中仍然存在 .swp 文件的记录。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>juicefs gc --delete $META-URL </code></p><p>忘记格式可以参考 (postgres:&#x2F;&#x2F;juicefs:****@localhost:5432&#x2F;bucket6)</p><p><img src="/../images/juicefs-gc/juicefs_gc.png" alt="image"><br>再次查看就很清爽了</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><code>--delete</code>这个选项会真正删除标记为垃圾的数据。默认情况下，juicefs gc 只会标记垃圾数据，而不会立即删除它们。</p><p><code>--threads</code>这个选项允许你指定垃圾回收的线程数。增加线程数可以提高垃圾回收的速度，但也会消耗更多的系统资源。</p><p><code>--dry-run</code>这个选项允许你进行一次“干运行”，即只列出将被删除的文件，而不实际删除它们。这对于预览垃圾回收的结果非常有用。</p><p><code>--min-age</code> 这个选项允许你指定被认为是垃圾数据的最小年龄。例如，–min-age&#x3D;7d 表示只有超过 7 天没有被访问的数据才会被认为是垃圾数据。</p><p>例如：想删除所有超过 7 天没有被访问的垃圾数据，并使用 4 个线程进行垃圾回收,可以这样写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">juicefs gc --delete --threads=4 --min-age=7d $META-URL</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在运行 juicefs gc 命令之前，建议先使用 –dry-run 选项进行一次“干运行”，以确保你知道哪些数据将被删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> juicefs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离线服务器迁移安装docker镜像</title>
      <link href="/2025/01/10/moveImg/"/>
      <url>/2025/01/10/moveImg/</url>
      
        <content type="html"><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>服务器需要使用容器，但是服务器是离线状态，或者无法直接拉取docker镜像，这时候就需要本篇文章了</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="步骤-1-将镜像导出为-tar-文件"><a href="#步骤-1-将镜像导出为-tar-文件" class="headerlink" title="步骤 1: 将镜像导出为 tar 文件"></a>步骤 1: 将镜像导出为 tar 文件</h5><p>首先，在在线服务器上将镜像导出为一个 .tar 文件。你可以使用 docker save 命令来将镜像导出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o /path/to/your-image.tar your-image:tag</span><br></pre></td></tr></table></figure><p><code>/path/to/your-image.tar</code> 是你要保存镜像文件的路径。</p><p><code>your-image:tag</code> 是你要导出的镜像名称和标签（例如：ubuntu:20.04）。</p><p><strong>补充：</strong></p><p>如果想要将正在运行的容器打包成镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker commit my_container my_new_image:v1.0</span><br><span class="line"># 其中：</span><br><span class="line"># my_container 是容器的名称或 ID。</span><br><span class="line"># my_new_image 是新镜像的名称。</span><br><span class="line"># v1.0 是镜像的标签（可选）。</span><br><span class="line"># 其他选项</span><br><span class="line"># -a, --author string：指定镜像的作者。</span><br><span class="line"># -m, --message string：添加镜像的提交信息。</span><br></pre></td></tr></table></figure><h5 id="步骤-2-将镜像文件传输到离线服务器"><a href="#步骤-2-将镜像文件传输到离线服务器" class="headerlink" title="步骤 2: 将镜像文件传输到离线服务器"></a>步骤 2: 将镜像文件传输到离线服务器</h5><p>将导出的 .tar 文件从在线服务器传输到离线服务器。可以使用任何支持文件传输的工具，如 scp、rsync、USB 存储等。</p><p>如果你有 SSH 访问权限，可以使用 scp 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /path/to/your-image.tar user@offline-server:/path/to/destination/</span><br></pre></td></tr></table></figure><p><code>/path/to/your-image.tar</code> 是本地文件路径。</p><p><code>user@offline-server:/path/to/destination/</code> 是离线服务器的目标路径。</p><h5 id="步骤-3-在离线服务器上加载镜像"><a href="#步骤-3-在离线服务器上加载镜像" class="headerlink" title="步骤 3: 在离线服务器上加载镜像"></a>步骤 3: 在离线服务器上加载镜像</h5><p>在离线服务器上使用 docker load 命令将镜像加载到 Docker 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i /path/to/your-image.tar</span><br></pre></td></tr></table></figure><p><code>/path/to/your-image.tar</code> 是传输过来的镜像文件路径。</p><p>加载成功后，你可以使用 docker images 命令查看是否成功导入镜像。</p><h5 id="步骤-4-启动容器"><a href="#步骤-4-启动容器" class="headerlink" title="步骤 4: 启动容器"></a>步骤 4: 启动容器</h5><p>一旦镜像成功加载，你就可以使用 docker run 启动容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-container your-image:tag</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数是让容器在后台运行。</p><p><code>--name my-container</code> 是容器的名称。</p><p><code>your-image:tag</code> 是加载的镜像名称和标签。</p><h5 id="步骤-5-验证容器是否启动"><a href="#步骤-5-验证容器是否启动" class="headerlink" title="步骤 5: 验证容器是否启动"></a>步骤 5: 验证容器是否启动</h5><p>使用以下命令查看容器是否成功启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>如果容器正在运行，它会出现在列表中。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、使用 docker save 命令将镜像导出为 .tar 文件。<br>2、使用 scp 或其他方式将 .tar 文件传输到离线服务器。<br>3、在离线服务器上使用 docker load 命令加载镜像。<br>4、使用 docker run 命令启动容器。<br>5、这样你就可以成功将镜像从在线服务器迁移到离线服务器并启动容器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解Dockerfile，是什么？主要指令？如何使用？</title>
      <link href="/2025/01/09/Dockerfile/"/>
      <url>/2025/01/09/Dockerfile/</url>
      
        <content type="html"><![CDATA[<h4 id="Dockerfile是什么？"><a href="#Dockerfile是什么？" class="headerlink" title="Dockerfile是什么？"></a>Dockerfile是什么？</h4><p>Dockerfile 是一个文本文件，其中包含了一系列指令，用来自动化构建 Docker 镜像。它的主要作用就是定义一个 Docker 镜像的构建过程，包括镜像的基础镜像、安装的软件、设置的环境变量、暴露的端口、执行的命令等。</p><h4 id="主要指令有哪些？"><a href="#主要指令有哪些？" class="headerlink" title="主要指令有哪些？"></a>主要指令有哪些？</h4><h5 id="1、FROM：指定基础镜像。"><a href="#1、FROM：指定基础镜像。" class="headerlink" title="1、FROM：指定基础镜像。"></a>1、FROM：指定基础镜像。</h5><p><code>FROM ubuntu:20.04</code>，表示使用 ubuntu 20.04 作为基础镜像。</p><h5 id="2、RUN：在镜像构建过程中执行命令（通常用于安装软件）。"><a href="#2、RUN：在镜像构建过程中执行命令（通常用于安装软件）。" class="headerlink" title="2、RUN：在镜像构建过程中执行命令（通常用于安装软件）。"></a>2、RUN：在镜像构建过程中执行命令（通常用于安装软件）。</h5><p><code>RUN apt-get update &amp;&amp; apt-get install -y curl</code>，表示在镜像中安装 curl 软件。</p><h5 id="3、COPY-ADD：将文件从本地复制到镜像中。"><a href="#3、COPY-ADD：将文件从本地复制到镜像中。" class="headerlink" title="3、COPY &#x2F; ADD：将文件从本地复制到镜像中。"></a>3、COPY &#x2F; ADD：将文件从本地复制到镜像中。</h5><p><code>COPY ./myapp /app</code>，表示将当前目录下的 myapp 文件夹复制到镜像中的 &#x2F;app 目录。</p><h5 id="4、WORKDIR：设置工作目录，后续的命令都会在该目录下执行。"><a href="#4、WORKDIR：设置工作目录，后续的命令都会在该目录下执行。" class="headerlink" title="4、WORKDIR：设置工作目录，后续的命令都会在该目录下执行。"></a>4、WORKDIR：设置工作目录，后续的命令都会在该目录下执行。</h5><p><code>WORKDIR /app</code>，设置工作目录为 &#x2F;app。</p><h5 id="5、EXPOSE：暴露容器的端口，供外部访问。"><a href="#5、EXPOSE：暴露容器的端口，供外部访问。" class="headerlink" title="5、EXPOSE：暴露容器的端口，供外部访问。"></a>5、EXPOSE：暴露容器的端口，供外部访问。</h5><p><code>EXPOSE 8080</code>，表示容器会监听 8080 端口。</p><h5 id="6、CMD-ENTRYPOINTCMD-ENTRYPOINT：指定容器启动时执行的命令。"><a href="#6、CMD-ENTRYPOINTCMD-ENTRYPOINT：指定容器启动时执行的命令。" class="headerlink" title="6、CMD &#x2F; ENTRYPOINTCMD &#x2F; ENTRYPOINT：指定容器启动时执行的命令。"></a>6、CMD &#x2F; ENTRYPOINTCMD &#x2F; ENTRYPOINT：指定容器启动时执行的命令。</h5><p>是容器启动时的默认命令，但可以被 docker run 覆盖；ENTRYPOINT 是容器启动时的强制命令。</p><p><code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>，表示容器启动时会执行 python app.py。</p><h4 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ImgName .</span><br></pre></td></tr></table></figure><ul><li><p><code>-t ImgName</code> -t 是 tag 的缩写，用来为新构建的镜像命名和打标签。在这里，ImgName 就是你要给这个镜像命名的名称。</p></li><li><p><code>.</code>  这个点（.）表示当前目录。Docker 将从这个目录下的 Dockerfile 文件开始构建镜像。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解 AI 对话中的 Token？</title>
      <link href="/2024/12/06/AiToken/"/>
      <url>/2024/12/06/AiToken/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是Token？"><a href="#一、什么是Token？" class="headerlink" title="一、什么是Token？"></a>一、什么是Token？</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1. 定义："></a>1. 定义：</h4><p>在自然语言处理（NLP）和AI对话系统中，token通常指的是文本中的一个单元，可以是一个单词、一个标点符号、一个数字，或者甚至是一个子词（如“playing”可以被分成“play”和“##ing”）。</p><h4 id="2-通俗理解："><a href="#2-通俗理解：" class="headerlink" title="2. 通俗理解："></a>2. 通俗理解：</h4><p>想象你正在玩拼图游戏，每个拼图块代表一个单词或符号，这些拼图块就是tokens。AI系统通过识别和处理这些拼图块来理解和生成语言。</p><h3 id="二、Token在AI对话中的作用："><a href="#二、Token在AI对话中的作用：" class="headerlink" title="二、Token在AI对话中的作用："></a>二、Token在AI对话中的作用：</h3><h4 id="1-输入和输出："><a href="#1-输入和输出：" class="headerlink" title="1. 输入和输出："></a>1. 输入和输出：</h4><p>当你向AI输入一句话时，AI首先会将这句话拆分成tokens，然后处理这些tokens来理解你的意思。同样，当AI生成回应时，它也是基于tokens来构建句子。</p><h4 id="2-模型训练："><a href="#2-模型训练：" class="headerlink" title="2. 模型训练："></a>2. 模型训练：</h4><p>在训练AI模型时，token是数据的基本单位。模型通过学习大量的tokens组合来理解语言的结构、语义和语法。</p><h4 id="3-上下文理解："><a href="#3-上下文理解：" class="headerlink" title="3. 上下文理解："></a>3. 上下文理解：</h4><p>Tokens帮助AI理解上下文。通过分析tokens的顺序和它们之间的关系，AI可以理解句子的意思。</p><h4 id="4-效率："><a href="#4-效率：" class="headerlink" title="4. 效率："></a>4. 效率：</h4><p>使用tokens可以提高处理效率，因为AI可以更快地识别和处理预定义的单元，而不是每次都从头开始解析整个文本。</p><h3 id="三、如何理解Token的数量："><a href="#三、如何理解Token的数量：" class="headerlink" title="三、如何理解Token的数量："></a>三、如何理解Token的数量：</h3><ul><li><p>数量：在AI对话中，通常会有一个token数量的限制，因为每个token都需要计算资源来处理。AI系统可能限制一次性处理的token数量，以保持响应的速度和效率。</p></li><li><p>长度限制：例如，一个AI系统可能限制每轮对话处理不超过512个tokens。这意味着你输入的文本和AI生成的文本加起来不能超过这个限制。</p></li></ul><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><ul><li><p>输入：“How are you today?”<br>这个句子可以被分成tokens：[‘How’, ‘are’, ‘you’, ‘today’, ‘?’]</p></li><li><p>处理：AI通过识别这些tokens，理解这是一个问候，并准备一个合适的回答。</p></li><li><p>输出：“I am doing well, thank you for asking!”<br>这里的每个单词或标点符号也是tokens，AI通过组合这些tokens来生成一个自然的回答。</p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Token在AI对话中就像是语言的基本构件块，通过对这些构件块的识别、处理和生成，AI能够模拟人类的语言交流。理解token有助于我们更好地理解AI是如何处理和理解语言的，同时也解释了为什么有些时候AI对话系统会有长度限制或处理时间的考虑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核ceph_mount流程</title>
      <link href="/2024/11/21/ceph-mount%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/11/21/ceph-mount%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="内核ceph-mount流程"><a href="#内核ceph-mount流程" class="headerlink" title="内核ceph_mount流程"></a>内核ceph_mount流程</h2><h3 id="1-用户空间命令行发起-mount-请求"><a href="#1-用户空间命令行发起-mount-请求" class="headerlink" title="1. 用户空间命令行发起 mount 请求"></a>1. 用户空间命令行发起 mount 请求</h3><p><code>mount -t ceph $(hostname):6789:/ /mnt/ceph/ -o name=admin,secret=$(ceph auth get-key client.admin)</code></p><p>执行这条ceph挂载命令时会发生什么？</p><h3 id="2-进入内核-sys-mount-系统调用"><a href="#2-进入内核-sys-mount-系统调用" class="headerlink" title="2. 进入内核 sys_mount 系统调用"></a>2. 进入内核 sys_mount 系统调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,</span><br><span class="line">char __user *, type, unsigned long, flags, void __user *, data)</span><br></pre></td></tr></table></figure><p>sys_mount 接受用户传入的设备名、挂载点、文件系统类型、挂载标志和挂载选项。<br>它将参数传递给 do_mount() 函数，进行更详细的挂载操作。</p><h3 id="3-do-mount-函数"><a href="#3-do-mount-函数" class="headerlink" title="3. do_mount() 函数"></a>3. do_mount() 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long do_mount(const char *dev_name, const char __user *dir_name,</span><br><span class="line">const char *type_page, unsigned long flags, void *data_page)</span><br></pre></td></tr></table></figure><p>do_mount 函数负责解析和检查挂载参数。</p><p>调用 do_new_mount 函数，尝试将文件系统挂载到指定路径。</p><h3 id="4-do-new-mount-函数"><a href="#4-do-new-mount-函数" class="headerlink" title="4. do_new_mount() 函数"></a>4. do_new_mount() 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int do_new_mount(struct path *path, const char *fstype, int flags,</span><br><span class="line">int mnt_flags, const char *name, void *data)</span><br></pre></td></tr></table></figure><p>do_new_mount 主要负责创建 vfsmount 结构并调用 vfs_kern_mount 函数，向虚拟文件系统（VFS）提交挂载请求。</p><p>vfsmount 是一个内核结构体，用于在 VFS 中表示文件系统的挂载点，包含挂载的信息和路径。</p><h3 id="5-vfs-kern-mount-函数"><a href="#5-vfs-kern-mount-函数" class="headerlink" title="5. vfs_kern_mount() 函数"></a>5. vfs_kern_mount() 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct vfsmount *</span><br><span class="line">vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)</span><br></pre></td></tr></table></figure><p>vfs_kern_mount 是挂载路径的关键函数，它通过文件系统类型（file_system_type）找到具体的挂载函数，并创建一个 vfsmount 结构。</p><p>调用 type-&gt;mount()，即调用对应文件系统类型的 mount 函数。</p><p>对于 Ceph 文件系统，file_system_type 是 ceph_fs_type，它的 mount 函数是 ceph_mount()。</p><h3 id="6-ceph-mount-函数"><a href="#6-ceph-mount-函数" class="headerlink" title="6. ceph_mount() 函数"></a>6. ceph_mount() 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static struct dentry *ceph_mount(struct file_system_type *fs_type,</span><br><span class="line">       int flags, const char *dev_name, void *data)</span><br></pre></td></tr></table></figure><p>ceph_mount 是 Ceph 文件系统特有的挂载函数。</p><p>ceph_mount 主要负责初始化 Ceph 文件系统客户端，连接到 Ceph 集群，并创建文件系统的根目录（dentry）。</p><p>ceph_mount 使用 Ceph 的用户态库（libceph）进行 Ceph 集群通信，包括连接到 Ceph Monitor、OSD 等服务。</p><p>挂载成功后返回根目录 dentry 给 VFS。</p><p>详细看一下代码！！！<br><code>ceph mount</code>过程，主要在<code>fs/ceph/super.c</code>文件中。</p><p><code>ceph_mount</code>解析挂载选项，创建文件客户端，初始化mds客户端，然后进入到<code>ceph_real_mount</code>；<code>ceph_real_mount</code> 将客户端节点挂载到 Ceph 文件系统集群，并打开文件系统的根目录。其中<code>__ceph_open_session - ceph_monc_open_session</code>建立与mon的连接。<code>open_root_dentry - ceph_mdsc_create_request</code>建立与mds的连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">static struct dentry *ceph_mount(struct file_system_type *fs_type,</span><br><span class="line">       int flags, const char *dev_name, void *data)</span><br><span class="line">&#123;</span><br><span class="line">struct super_block *sb;</span><br><span class="line">struct ceph_fs_client *fsc;</span><br><span class="line">struct dentry *res;</span><br><span class="line">int err;</span><br><span class="line">int (*compare_super)(struct super_block *, void *) = ceph_compare_super;</span><br><span class="line">struct ceph_mount_options *fsopt = NULL;</span><br><span class="line">struct ceph_options *opt = NULL;</span><br><span class="line"></span><br><span class="line">dout(&quot;ceph_mount\n&quot;);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CEPH_FS_POSIX_ACL</span><br><span class="line">flags |= MS_POSIXACL;</span><br><span class="line">#endif</span><br><span class="line">err = parse_mount_options(&amp;fsopt, &amp;opt, flags, data, dev_name);</span><br><span class="line">if (err &lt; 0) &#123;</span><br><span class="line">res = ERR_PTR(err);</span><br><span class="line">goto out_final;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* create client (which we may/may not use) */</span><br><span class="line">fsc = create_fs_client(fsopt, opt);</span><br><span class="line">if (IS_ERR(fsc)) &#123;</span><br><span class="line">res = ERR_CAST(fsc);</span><br><span class="line">destroy_mount_options(fsopt);</span><br><span class="line">ceph_destroy_options(opt);</span><br><span class="line">goto out_final;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ceph_mdsc_init(fsc);</span><br><span class="line">if (err &lt; 0) &#123;</span><br><span class="line">res = ERR_PTR(err);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ceph_test_opt(fsc-&gt;client, NOSHARE))</span><br><span class="line">compare_super = NULL;</span><br><span class="line">sb = sget(fs_type, compare_super, ceph_set_super, flags, fsc);</span><br><span class="line">if (IS_ERR(sb)) &#123;</span><br><span class="line">res = ERR_CAST(sb);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ceph_sb_to_client(sb) != fsc) &#123;</span><br><span class="line">ceph_mdsc_destroy(fsc);</span><br><span class="line">destroy_fs_client(fsc);</span><br><span class="line">fsc = ceph_sb_to_client(sb);</span><br><span class="line">dout(&quot;get_sb got existing client %p\n&quot;, fsc);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dout(&quot;get_sb using new client %p\n&quot;, fsc);</span><br><span class="line">err = ceph_register_bdi(sb, fsc);</span><br><span class="line">if (err &lt; 0) &#123;</span><br><span class="line">res = ERR_PTR(err);</span><br><span class="line">goto out_splat;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = ceph_real_mount(fsc);</span><br><span class="line">if (IS_ERR(res))</span><br><span class="line">goto out_splat;</span><br><span class="line">dout(&quot;root %p inode %p ino %llx.%llx\n&quot;, res,</span><br><span class="line">     res-&gt;d_inode, ceph_vinop(res-&gt;d_inode));</span><br><span class="line">return res;</span><br><span class="line"></span><br><span class="line">out_splat:</span><br><span class="line">ceph_mdsc_close_sessions(fsc-&gt;mdsc);</span><br><span class="line">deactivate_locked_super(sb);</span><br><span class="line">goto out_final;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">ceph_mdsc_destroy(fsc);</span><br><span class="line">destroy_fs_client(fsc);</span><br><span class="line">out_final:</span><br><span class="line">dout(&quot;ceph_mount fail %ld\n&quot;, PTR_ERR(res));</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static struct dentry *ceph_real_mount(struct ceph_fs_client *fsc)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">unsigned long started = jiffies;  /* note the start time */</span><br><span class="line">struct dentry *root;</span><br><span class="line"></span><br><span class="line">dout(&quot;mount start %p\n&quot;, fsc);</span><br><span class="line">mutex_lock(&amp;fsc-&gt;client-&gt;mount_mutex);</span><br><span class="line"></span><br><span class="line">if (!fsc-&gt;sb-&gt;s_root) &#123;</span><br><span class="line">const char *path;</span><br><span class="line">err = __ceph_open_session(fsc-&gt;client, started);</span><br><span class="line">if (err &lt; 0)</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line">if (!fsc-&gt;mount_options-&gt;server_path) &#123;</span><br><span class="line">path = &quot;&quot;;</span><br><span class="line">dout(&quot;mount opening path \\t\n&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">path = fsc-&gt;mount_options-&gt;server_path + 1;</span><br><span class="line">dout(&quot;mount opening path %s\n&quot;, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ceph_fs_debugfs_init(fsc);</span><br><span class="line">if (err &lt; 0)</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line">root = open_root_dentry(fsc, path, started);</span><br><span class="line">if (IS_ERR(root)) &#123;</span><br><span class="line">err = PTR_ERR(root);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line">fsc-&gt;sb-&gt;s_root = dget(root);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">root = dget(fsc-&gt;sb-&gt;s_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fsc-&gt;mount_state = CEPH_MOUNT_MOUNTED;</span><br><span class="line">dout(&quot;mount success\n&quot;);</span><br><span class="line">mutex_unlock(&amp;fsc-&gt;client-&gt;mount_mutex);</span><br><span class="line">return root;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;fsc-&gt;client-&gt;mount_mutex);</span><br><span class="line">return ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-返回到用户空间"><a href="#7-返回到用户空间" class="headerlink" title="7. 返回到用户空间"></a>7. 返回到用户空间</h3><p>挂载成功后，sys_mount 返回到用户空间，mount 命令得到返回结果。</p><p>此时，Ceph 文件系统的根目录已经挂载在指定的挂载点，用户可以通过挂载点访问 Ceph 文件系统。</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>在<code>/var/log/messages</code>中只看到这两条相关日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nov xx 11:03:56 node1 kernel: libceph: mon0 192.xxx.xxx.xxx:6789 session established</span><br><span class="line">Nov xx 11:03:56 node1 kernel: libceph: client50981349 fsid ed69ef4c-63ed-436f-a733-c53c0037105d</span><br></pre></td></tr></table></figure><p>以上日志信息远远不够，准备提高内核日志打印级别继续看看。</p><h4 id="内核日志级别调整"><a href="#内核日志级别调整" class="headerlink" title="内核日志级别调整"></a>内核日志级别调整</h4><p>内核日志级别可以通过<code>/proc/sys/kernel/printk</code>文件来修改</p><p>先来看看这个文件初始是什么样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# cat /proc/sys/kernel/printk</span><br><span class="line">4417</span><br></pre></td></tr></table></figure><p>这四个值的定义可以在<code>kernel/printk.c</code>中找到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int console_printk[4] = &#123;</span><br><span class="line">DEFAULT_CONSOLE_LOGLEVEL,/* console_loglevel */</span><br><span class="line">DEFAULT_MESSAGE_LOGLEVEL,/* default_message_loglevel */</span><br><span class="line">MINIMUM_CONSOLE_LOGLEVEL,/* minimum_console_loglevel */</span><br><span class="line">DEFAULT_CONSOLE_LOGLEVEL,/* default_console_loglevel */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而内核日志级别有以下七种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define KERN_EMERGKERN_SOH &quot;0&quot;/* system is unusable */</span><br><span class="line">#define KERN_ALERTKERN_SOH &quot;1&quot;/* action must be taken immediately */</span><br><span class="line">#define KERN_CRITKERN_SOH &quot;2&quot;/* critical conditions */</span><br><span class="line">#define KERN_ERRKERN_SOH &quot;3&quot;/* error conditions */</span><br><span class="line">#define KERN_WARNINGKERN_SOH &quot;4&quot;/* warning conditions */</span><br><span class="line">#define KERN_NOTICEKERN_SOH &quot;5&quot;/* normal but significant condition */</span><br><span class="line">#define KERN_INFOKERN_SOH &quot;6&quot;/* informational */</span><br><span class="line">#define KERN_DEBUGKERN_SOH &quot;7&quot;/* debug-level messages */</span><br><span class="line"></span><br><span class="line">#define KERN_DEFAULTKERN_SOH &quot;d&quot;/* the default kernel loglevel */</span><br></pre></td></tr></table></figure><p>只需要调整对应数字就可以，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo 8 4 1 7 &gt; /proc/sys/kernel/printk</span><br><span class="line">注意：控制台只会显示大于所设置等级的信息，比如想要看debug(7)日志信息，需要设置为7以上</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">确保/etc/rsyslog.conf文件中 #kern.* 注释被取消！</span><br><span class="line">systemctl restart rsyslog</span><br><span class="line">这样内核产生的所有日志信息都会被记录到相应的文件中，包括 dout 产生的调试信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>补充：<br><code>dmesg</code> 的信息在环缓冲区中，只包含最新的内核日志；<br><code>/var/log/messages</code> 是磁盘上的文件，保留较长时间的日志记录。</p></blockquote><h4 id="补充-内核开启DEBUG"><a href="#补充-内核开启DEBUG" class="headerlink" title="补充 - 内核开启DEBUG"></a>补充 - 内核开启DEBUG</h4><p>在生产环境中，出于安全和性能的考虑，可能会禁用调试信息，这时候调整日志打印级别是不生效的，这时候需要在内核代码中打开DEBUG<br><strong>方法一</strong><br>修改Makefile文件，比如我们要打开fs&#x2F;ceph&#x2F;下所有文件及子目录下的DEBUG宏，可以在fs&#x2F;ceph&#x2F;Makefile中添加<code>subdir-ccflags-y := -DDEBUG</code>选项</p><p><strong>方法二</strong><br>在<code>pr_debug/dev_dbg</code>模块最上面加上<code>#define DEBUG</code>语句</p><p>开启之后，在dmesg中就可以看到pr_debug&#x2F;dev_dbg的打印信息了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ceph </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juicefs元数据及数据存储方式</title>
      <link href="/2024/11/01/juicefs%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/11/01/juicefs%E5%85%83%E6%95%B0%E6%8D%AE%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><p>文件系统使用juicefs，元数据存储使用postgresql，数据存储使用minio</p><h5 id="问题？"><a href="#问题？" class="headerlink" title="问题？"></a>问题？</h5><p>通过juicefs写入一个文件，元数据在postgresql中是如何存储的？数据在minio中又是如何存储的？</p><p>新建 <code>file1、dir1/file1、dir1/file2</code>三个文件，大小分别为<code>4B 9B 13B</code></p><h5 id="在postgresql中"><a href="#在postgresql中" class="headerlink" title="在postgresql中"></a>在postgresql中</h5><p><code>jfs_node</code>表中记录着文件元数据信息</p><p><img src="/../images/juicefs_meta/jfs_node.png" alt="image"></p><p><code>jfs_chunk</code>表中记录着文件分片信息</p><p><img src="/../images/juicefs_meta/jfs_chunk.png" alt="image"></p><p>slices中可以看到存着一堆16进制代码，看看juicefs源码里slices的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Slice struct &#123;</span><br><span class="line">    Pos  uint32 // offset of the Slice in the Chunk</span><br><span class="line">    ID   uint64 // ID of the Slice, globally unique</span><br><span class="line">    Size uint32 // size of the Slice</span><br><span class="line">    Off  uint32 // offset of valid data in this Slice</span><br><span class="line">    Len  uint32 // size of valid data in this Slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在二进制存储中，每2个十六进制字符代表1个字节</p><p>以slices <code>\x0000000000000000000000040000000d000000000000000d</code>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000          Slice 在 Chunk 中的偏移位置为0</span><br><span class="line">0000000000000004  Slice 的 ID，全局唯一（chunkid）转换为10进制数为4,</span><br><span class="line">0000000d          slice 的总大小为13</span><br><span class="line">00000000          有效数据在此 Slice 中的偏移位置</span><br><span class="line">0000000d          有效数据在此 Slice 中的大小为13</span><br></pre></td></tr></table></figure><p>由上可解析出slice的各部分信息，跟以下chunk_ref表中的数据也能够一一对应</p><p><code>jfs_chunk_ref</code>表中记录着文件分片补充信息</p><p><img src="/../images/juicefs_meta/jfs_chunk_ref.png" alt="image"></p><h5 id="在minio中"><a href="#在minio中" class="headerlink" title="在minio中"></a>在minio中</h5><p>可以看到具体的数据已经按照一定的层级存储到了minio中</p><p><img src="/../images/juicefs_meta/minio.png" alt="image"></p><blockquote><p>目录层级关系和名字看着很陌生，是以什么规则进行的呢？层级中的<code>chunks/0/0/</code>是怎么来的？对象名字<code>4_0_13</code>是怎么来的？</p></blockquote><p>查看源码得知，在<code>juicefs/pkg/chunk/cached_store.go</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (s *rSlice) key(indx int) string &#123;</span><br><span class="line">if s.store.conf.HashPrefix &#123;</span><br><span class="line">return fmt.Sprintf(&quot;chunks/%02X/%v/%v_%v_%v&quot;, s.id%256, s.id/1000/1000, s.id, indx, s.blockSize(indx))</span><br><span class="line">&#125;</span><br><span class="line">return fmt.Sprintf(&quot;chunks/%v/%v/%v_%v_%v&quot;, s.id/1000/1000, s.id/1000, s.id, indx, s.blockSize(indx))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入一个index字段，最终生成一个字符串类型的路径，HashPrefix是一个配置项，以chunk表中id为3的数据为例，slice解析后的id为4，index为0，所以会返回<code>chunks/0/0/,4_0_13</code>，也能够跟minio中的数据一一对应</p><p>至此已基本了解文件到对象的元数据集数据的存储方式</p>]]></content>
      
      
      
        <tags>
            
            <tag> Juicefs </tag>
            
            <tag> Minio </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go test</title>
      <link href="/2024/09/24/go-test/"/>
      <url>/2024/09/24/go-test/</url>
      
        <content type="html"><![CDATA[<p><code>go test</code> 是 Go 语言的内置工具，用于自动化测试 Go 代码。</p><h3 id="1、测试文件结构"><a href="#1、测试文件结构" class="headerlink" title="1、测试文件结构"></a>1、测试文件结构</h3><ul><li><p><code>测试文件名</code>必须以 _test.go 结尾。例如：example_test.go。</p></li><li><p><code>测试函数名称</code>必须以 Test 开头，参数类型为 *testing.T</p></li></ul><h3 id="2、测试命令"><a href="#2、测试命令" class="headerlink" title="2、测试命令"></a>2、测试命令</h3><blockquote><p>在当前目录运行所有测试<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure><br>运行特定的测试函数<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -run Testfunc</span><br></pre></td></tr></table></figure><br>查看代码覆盖率<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -cover</span><br></pre></td></tr></table></figure><br>生成详细的测试覆盖率报告<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go test -coverprofile=coverage.out</span><br><span class="line">go tool cover -func=coverage.out</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="3、额外测试"><a href="#3、额外测试" class="headerlink" title="3、额外测试"></a>3、额外测试</h3><blockquote><p>基准测试</p></blockquote><p>基准测试函数以 Benchmark 开头，参数类型为 *testing.B </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=.</span><br></pre></td></tr></table></figure><blockquote><p>并发测试</p></blockquote><p>使用 Go 的 t.Parallel() 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line">    result := Add(1, 2)</span><br><span class="line">    if result != 3 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(1, 2) = %d; want 3&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、其他常用标志"><a href="#4、其他常用标志" class="headerlink" title="4、其他常用标志"></a>4、其他常用标志</h3><blockquote><p>-timeout：设置测试的超时时间。例如，-timeout 30s。</p></blockquote><blockquote><p>-coverpkg：计算多个包的覆盖率。</p></blockquote><blockquote><p>-short：运行短测试，跳过长时间运行的测试。</p></blockquote><blockquote><p>-json：以 JSON 格式输出测试结果。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JuiceFS元数据引擎PostgreSQL</title>
      <link href="/2024/08/27/JuiceFS%E5%85%83%E6%95%B0%E6%8D%AE%E5%BC%95%E6%93%8EPostgreSQL/"/>
      <url>/2024/08/27/JuiceFS%E5%85%83%E6%95%B0%E6%8D%AE%E5%BC%95%E6%93%8EPostgreSQL/</url>
      
        <content type="html"><![CDATA[<p>使用PostgreSQL作为JuiceFS元数据引擎，各表的含义和字段做一个简单归纳</p><blockquote><p>juicefs数据库用于存储juicefs文件信息</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=# \l</span><br><span class="line">                                                      List of databases</span><br><span class="line">   Name    |  Owner   | Encoding | Locale Provider |  Collate   |   Ctype    | ICU Locale | ICU Rules |   Access privileges</span><br><span class="line">-----------+----------+----------+-----------------+------------+------------+------------+-----------+-----------------------</span><br><span class="line"> juicefs   | juicefs  | UTF8     | libc            | en_US.utf8 | en_US.utf8 |            |           |</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以看到数据库包含了很多张表</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">juicefs=# \dt</span><br><span class="line">              List of relations</span><br><span class="line"> Schema |       Name        | Type  |  Owner</span><br><span class="line">--------+-------------------+-------+---------</span><br><span class="line"> public | jfs_acl           | table | juicefs</span><br><span class="line"> public | jfs_chunk         | table | juicefs</span><br><span class="line"> public | jfs_chunk_ref     | table | juicefs</span><br><span class="line"> public | jfs_counter       | table | juicefs</span><br><span class="line"> public | jfs_delfile       | table | juicefs</span><br><span class="line"> public | jfs_delslices     | table | juicefs</span><br><span class="line"> public | jfs_detached_node | table | juicefs</span><br><span class="line"> public | jfs_dir_quota     | table | juicefs</span><br><span class="line"> public | jfs_dir_stats     | table | juicefs</span><br><span class="line"> public | jfs_edge          | table | juicefs</span><br><span class="line"> public | jfs_flock         | table | juicefs</span><br><span class="line"> public | jfs_node          | table | juicefs</span><br><span class="line"> public | jfs_plock         | table | juicefs</span><br><span class="line"> public | jfs_session2      | table | juicefs</span><br><span class="line"> public | jfs_setting       | table | juicefs</span><br><span class="line"> public | jfs_sustained     | table | juicefs</span><br><span class="line"> public | jfs_symlink       | table | juicefs</span><br><span class="line"> public | jfs_xattr         | table | juicefs</span><br><span class="line">(18 rows)</span><br></pre></td></tr></table></figure><ul><li><p><strong>jfs_setting       存储文件系统格式化信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  name  |                                                    value</span><br><span class="line">--------+--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> format | &#123;                                                                                                           +</span><br><span class="line">        | &quot;Name&quot;: &quot;juicefs&quot;,                                                                                          +</span><br><span class="line">        | &quot;UUID&quot;: &quot;6b1aaa0a-e3da-43db-ab4e-252a92f722bd&quot;,                                                             +</span><br><span class="line">        | &quot;Storage&quot;: &quot;s3&quot;,                                                                                            +</span><br><span class="line">        | &quot;Bucket&quot;: &quot;http://192.168.247.143:9000/bucket1&quot;,                                                            +</span><br><span class="line">        | &quot;AccessKey&quot;: &quot;jAzkO6aquJlH8daWJ0vC&quot;,                                                                        +</span><br><span class="line">        | &quot;SecretKey&quot;: &quot;UclQZeuePQcp9HmMd9Q0EUkL0QIb70ty9kPbbWRcpaYI0JjAUUsE6x8dZ4QxU3hLsK1EbesYB4DfJHeJzPzHUL+ch5A=&quot;,+</span><br><span class="line">        | &quot;BlockSize&quot;: 4096,                                                                                          +</span><br><span class="line">        | &quot;Compression&quot;: &quot;none&quot;,                                                                                      +</span><br><span class="line">        | &quot;EncryptAlgo&quot;: &quot;aes256gcm-rsa&quot;,                                                                             +</span><br><span class="line">        | &quot;KeyEncrypted&quot;: true,                                                                                       +</span><br><span class="line">        | &quot;TrashDays&quot;: 1,                                                                                             +</span><br><span class="line">        | &quot;MetaVersion&quot;: 1,                                                                                           +</span><br><span class="line">        | &quot;MinClientVersion&quot;: &quot;1.1.0-A&quot;,                                                                              +</span><br><span class="line">        | &quot;DirStats&quot;: true,                                                                                           +</span><br><span class="line">        | &quot;EnableACL&quot;: false                                                                                          +</span><br><span class="line">        | &#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_edge     存储文件名、inode号及父目录inode号信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> id | parent |     name     | inode | type</span><br><span class="line">----+--------+--------------+-------+------</span><br><span class="line">  1 |      1 | \x64697231   |     2 |    2</span><br><span class="line">  2 |      1 | \x66696c6531 |     3 |    1</span><br><span class="line">  3 |      2 | \x66696c6531 |     4 |    1</span><br><span class="line">  4 |      2 | \x66696c6532 |     5 |    1</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_node      存储文件系统的基本元数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        inode        | type | flags | mode | uid | gid |      atime       |      mtime       |      ctime       | atimensec | mtimensec | ctimensec | nlink | length | rdev | parent | access_acl_id | default_acl_id</span><br><span class="line">---------------------+------+-------+------+-----+-----+------------------+------------------+------------------+-----------+-----------+-----------+-------+--------+------+--------+---------------+----------------</span><br><span class="line"> 9223372032828243968 |    2 |     0 |  365 |   0 |   0 | 1720746821874411 | 1720746821874411 | 1720746821874411 |       855 |       855 |       855 |     2 |   4096 |    0 |      1 |             0 |              0</span><br><span class="line">                   1 |    2 |     0 |  511 |   0 |   0 | 1720746821874411 | 1720751372873926 | 1720751372873926 |       855 |       855 |       855 |     3 |   4096 |    0 |      1 |             0 |              0</span><br><span class="line">                   3 |    1 |     0 |  420 |   0 |   0 | 1720751372873926 | 1720751372878651 | 1720751372885031 |        42 |        11 |       201 |     1 |      4 |    0 |      1 |             0 |              0</span><br><span class="line">                   4 |    1 |     0 |  420 |   0 |   0 | 1720751407595564 | 1720751407598082 | 1720751407603477 |       450 |       178 |       346 |     1 |      9 |    0 |      2 |             0 |              0</span><br><span class="line">                   2 |    2 |     0 |  493 |   0 |   0 | 1720750221908578 | 1720751416940112 | 1720751416940112 |       916 |       916 |       916 |     2 |   4096 |    0 |      1 |             0 |              0</span><br><span class="line">                   5 |    1 |     0 |  420 |   0 |   0 | 1720751416940112 | 1720751416942616 | 1720751416946878 |       475 |       471 |       682 |     1 |     13 |    0 |      2 |             0 |              0</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_chunk    存储文件的块信息，slices分段记录着信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> id | inode | indx |                       slices</span><br><span class="line">----+-------+------+----------------------------------------------------</span><br><span class="line">  1 |     3 |    0 | \x000000000000000000000001000000040000000000000004</span><br><span class="line">  2 |     4 |    0 | \x000000000000000000000003000000090000000000000009</span><br><span class="line">  3 |     5 |    0 | \x0000000000000000000000040000000d000000000000000d</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_chunk_ref   chunkid与size可组成对象名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> chunkid | size | refs</span><br><span class="line">---------+------+------</span><br><span class="line">       1 |    4 |    1</span><br><span class="line">       3 |    9 |    1</span><br><span class="line">       4 |   13 |    1</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_counter     存储文件系统汇总计数信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        name         |   value</span><br><span class="line">---------------------+------------</span><br><span class="line"> nextSession         |          5</span><br><span class="line"> nextChunk           |       4097</span><br><span class="line"> usedSpace           |      16384</span><br><span class="line"> totalInodes         |          4</span><br><span class="line"> lastCleanupFiles    | 1722842479</span><br><span class="line"> lastCleanupSessions | 1722842515</span><br><span class="line"> nextCleanupSlices   | 1722840923</span><br><span class="line"> lastCleanupTrash    | 1722840440</span><br><span class="line"> nextInode           |       1026</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_dir_stats     存储着各目录状态信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> inode | data_length | used_space | used_inodes</span><br><span class="line">-------+-------------+------------+-------------</span><br><span class="line">     1 |           4 |       8192 |           2</span><br><span class="line">     2 |          22 |       8192 |           2</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_symlink   存储符号链接的信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> inode | target</span><br><span class="line">-------+--------</span><br><span class="line">(0 rows)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_xattr     存储扩展属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> id | inode |    name    |                   value</span><br><span class="line">----+-------+------------+--------------------------------------------</span><br><span class="line">  1 |     1 | lastBackup | \x323032342d30382d30355430363a30383a34335a</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_session2   存储客户端会话信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> sid |   expire   |                    info</span><br><span class="line">-----+------------+-------------------------------------------------------------</span><br><span class="line">   5 | 1722841562 | \x7b2256657273696f6e223a22312e322e302b323032342d</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_plock   存储文件锁的信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> id | inode | sid | owner | records</span><br><span class="line">----+-------+-----+-------+---------</span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_delfile      存储删除文件信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> inode | length | expire</span><br><span class="line">-------+--------+--------</span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>jfs_dir_quota      存储配额信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> inode | max_space | max_inodes | used_space | used_inodes</span><br><span class="line">-------+-----------+------------+------------+-------------</span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用nginx代理，实现扫描二维码查看静态网页功能</title>
      <link href="/2024/08/27/%E4%BD%BF%E7%94%A8nginx%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%9F%A5%E7%9C%8B%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%8A%9F%E8%83%BD/"/>
      <url>/2024/08/27/%E4%BD%BF%E7%94%A8nginx%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%9F%A5%E7%9C%8B%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="1、创建项目目录"><a href="#1、创建项目目录" class="headerlink" title="1、创建项目目录"></a>1、创建项目目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-image-page</span><br><span class="line">cd my-image-page</span><br></pre></td></tr></table></figure><h3 id="2、准备图片和HTML文件"><a href="#2、准备图片和HTML文件" class="headerlink" title="2、准备图片和HTML文件"></a>2、准备图片和HTML文件</h3><ul><li><p>上传图片：将 image.jpg 上传到 my-image-page 目录。</p></li><li><p>创建HTML文件：在同一目录下创建一个 index.html 文件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Image Display&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;image.jpg&quot; alt=&quot;Display Image&quot; style=&quot;width:100%; height:auto;&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="3、创建-Dockerfile"><a href="#3、创建-Dockerfile" class="headerlink" title="3、创建 Dockerfile"></a>3、创建 Dockerfile</h3><p>在 my-image-page 目录下创建一个 Dockerfile 文件，用于定义容器环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Nginx image as the base image</span><br><span class="line"># 此处若无法直接拉取镜像，可尝试使用代理 FROM docker.fxxk.dedyn.io/nginx:latest</span><br><span class="line">FROM nginx:latest</span><br><span class="line"></span><br><span class="line"># Copy the HTML and image files into the Nginx web directory</span><br><span class="line"># 拷贝服务器文件到镜像内 docker cp &lt;源文件路径&gt; &lt;容器名称&gt;:&lt;容器内路径&gt;</span><br><span class="line">COPY . /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line"># Expose port 80</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><h3 id="4、构建Docker镜像"><a href="#4、构建Docker镜像" class="headerlink" title="4、构建Docker镜像"></a>4、构建Docker镜像</h3><p>在项目目录 my-image-page 中，运行以下命令来构建Docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-image-page .</span><br></pre></td></tr></table></figure><p>这条命令会根据 Dockerfile 的内容创建一个名为 my-image-page 的Docker镜像。</p><h3 id="5、运行Docker容器"><a href="#5、运行Docker容器" class="headerlink" title="5、运行Docker容器"></a>5、运行Docker容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name my-image-container my-image-page</span><br></pre></td></tr></table></figure><ul><li><strong>-d</strong>：后台运行容器。</li><li><strong>-p 80:80</strong>：将容器的80端口映射到主机的80端口。</li><li><strong>–name my-image-container</strong>：为容器指定一个名字。</li></ul><h3 id="6、访问页面"><a href="#6、访问页面" class="headerlink" title="6、访问页面"></a>6、访问页面</h3><ul><li>获取服务器IP：确保云服务器的防火墙允许访问80端口。</li><li>访问静态页面：通过浏览器访问 <code>http://your-server-ip/</code> 或 <code>http://your-domain.com/</code>，应该能看到包含图片的静态页面。、</li></ul><h3 id="7、生成二维码"><a href="#7、生成二维码" class="headerlink" title="7、生成二维码"></a>7、生成二维码</h3><p>使用网站 <a href="https://www.qr-code-generator.com/">https://www.qr-code-generator.com/</a> 生成一个二维码，内容为 <code>http://your-server-ip/</code> 或 <code>http://your-domain.com/</code></p><h3 id="8、管理和更新"><a href="#8、管理和更新" class="headerlink" title="8、管理和更新"></a>8、管理和更新</h3><ul><li>查看运行中的容器：使用 <code>docker ps</code> 可以查看正在运行的容器。</li><li>停止容器：使用 <code>docker stop my-image-container</code> 可以停止容器。</li><li>删除容器：使用 <code>docker rm my-image-container</code> 可以删除容器。</li><li>更新内容：如果需要更新图片或HTML文件，修改文件后重新构建镜像，并运行新容器。</li></ul><p>这样，通过Docker，你可以轻松地将这个静态页面部署在容器中，并方便地进行管理和更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识和使用JuiceFS</title>
      <link href="/2024/06/13/%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BD%BF%E7%94%A8JuiceFS/"/>
      <url>/2024/06/13/%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BD%BF%E7%94%A8JuiceFS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>认识和使用minio</title>
      <link href="/2024/06/13/%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BD%BF%E7%94%A8minio/"/>
      <url>/2024/06/13/%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BD%BF%E7%94%A8minio/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是minio"><a href="#什么是minio" class="headerlink" title="什么是minio?"></a>什么是minio?</h3><p>minio 是一个基于Apache License v2.0开源协议的轻量对象存储服务，兼容亚马逊S3接口，号称目前速度最快，在标准硬件上，对象存储的读&#x2F;写速度最高可以高达183 GB&#x2F;s和171 GB&#x2F;s。</p><p>官网文档地址：<a href="https://docs.min.io/cn/">https://docs.min.io/cn/</a></p><h3 id="部署使用minio服务端"><a href="#部署使用minio服务端" class="headerlink" title="部署使用minio服务端"></a>部署使用minio服务端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#下载Minio服务器二进制文件</span><br><span class="line">wget https://dl.min.io/server/minio/release/linux-amd64/minio</span><br><span class="line">chmod +x minio</span><br><span class="line">mv minio /usr/local/bin/</span><br><span class="line">#创建存储目录</span><br><span class="line">mkdir /mnt/data</span><br><span class="line"></span><br><span class="line">#运行Minio服务器</span><br><span class="line">./minio server /mnt/data</span><br></pre></td></tr></table></figure><p>本次部署使用的服务器<code>内核版本为3.10.x.x</code>，开启服务后提示如下<code>信息及警告</code>：</p><p><img src="/../images/minio/minio_server.png" alt="image"></p><p>此时可以访问ui页面<code>http://127.0.0.1:9000</code>进行一些简单操作了！</p><p><img src="/../images/minio/minio_ui.png" alt="image"></p><h3 id="部署使用minio客户端"><a href="#部署使用minio客户端" class="headerlink" title="部署使用minio客户端"></a>部署使用minio客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#下载Minio客户端二进制文件</span><br><span class="line">wget https://dl.min.io/client/mc/release/linux-amd64/mc</span><br><span class="line">chmod +x mc</span><br><span class="line">mv mc /usr/local/bin/</span><br><span class="line"></span><br><span class="line">#配置Minio客户端</span><br><span class="line">mc alias set &#x27;myminio&#x27; &#x27;http://192.168.247.141:9000&#x27; &#x27;minioadmin&#x27; &#x27;minioadmin&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建存储桶</span><br><span class="line">mc mb myminio/mybucket</span><br><span class="line"></span><br><span class="line">#上传文件</span><br><span class="line">mc cp /path/to/localfile myminio/mybucket</span><br><span class="line"></span><br><span class="line">#列出存储桶中的文件</span><br><span class="line">mc ls myminio/mybucket</span><br><span class="line"></span><br><span class="line"># 下载文件</span><br><span class="line">mc cp myminio/mybucket/remote-file /path/to/localdir</span><br><span class="line"></span><br><span class="line"># 删除文件</span><br><span class="line">mc rm myminio/mybucket/remote-file</span><br></pre></td></tr></table></figure><p>至此可以初步认识和操作minio了，未完待续！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Minio </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prometheus + grafana 监测ceph集群状态</title>
      <link href="/2024/05/22/prometheus-grafana-%E7%9B%91%E6%B5%8Bceph%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81/"/>
      <url>/2024/05/22/prometheus-grafana-%E7%9B%91%E6%B5%8Bceph%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h5 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h5><p>最近在使用海量小文件压测ceph集群，<strong>想要一个可视化的界面来方便监测ceph集群状态</strong>，由于很久之前使用过prometheus + grafana 监测 k8s 集群状态，想着用来监测 ceph 集群应该问题不大，那么就开始吧！</p><p>首先了解下 <strong>prometheus 和 grafana 是什么</strong>？<br>通俗来讲，<strong>Prometheus可以通过各种方式采集应用程序和系统的指标数据</strong>，例如服务器的 CPU 使用率、内存使用率、网络流量等等。采集到的数据会存储在一个时间序列数据库中，用户可以使用PromQL查询语言进行查询和分析。同时，Prometheus还提供了告警机制，可以在监控数据超出设定的阈值时发出告警通知。而<strong>Grafana可以通过连接Prometheus数据源，将采集到的数据进行可视化展示</strong>，例如将 CPU 使用率和内存使用率用折线图的形式展示出来。用户可以通过配置仪表盘来自定义展示的数据和样式，以及添加告警规则和面板等。</p><p><strong>Prometheus + Grafana组合就是一套监控和可视化解决方案，可以帮助用户更好地监控和管理他们的应用程序、服务器和网络设备。</strong></p><p>在 Ceph Luminous (12.x) 之前的版本，可以使用第三方的 ceph_exporter 采集 Ceph 集群的监控信息。 从 Ceph Luminous 12.2.1 版本开始，MGR 中自带了 Prometheus 插件，内置了 Prometheus Ceph Exporter，可以使用 Ceph MGR 内置的 exporter 作为 Prometheus 的 target。</p><h4 id="一、启用-ceph-prometheus-模块"><a href="#一、启用-ceph-prometheus-模块" class="headerlink" title="一、启用 ceph prometheus 模块"></a>一、启用 ceph prometheus 模块</h4><p>任意一台ceph mgr节点执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph mgr module enable prometheus</span><br></pre></td></tr></table></figure><p>启用成功后可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# ceph mgr services</span><br><span class="line">&#123;</span><br><span class="line">    &quot;dashboard&quot;: &quot;https://node1:8443/&quot;,</span><br><span class="line">    &quot;prometheus&quot;: &quot;http://node1:9283/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 9283 是 ceph_exporter 的默认监听端口，访问 <code>http://&lt;MGR&gt;:9283/metrics</code> 可以获取到 metrics</p><p><img src="/../images/ui_1.png" alt="prometheus"></p><h4 id="二、安装-prometheus-server"><a href="#二、安装-prometheus-server" class="headerlink" title="二、安装 prometheus server"></a>二、安装 prometheus server</h4><h5 id="1、二进制安装"><a href="#1、二进制安装" class="headerlink" title="1、二进制安装"></a>1、二进制安装</h5><p>Prometheus 基于 Golang 编写，编译后的软件包，不依赖于任何的第三方依赖。所以只需要下载对应平台的二进制包，解压并且添加基本的配置即可正常启动 Prometheus Server。</p><p>下载地址：<a href="https://prometheus.io/download/">https://prometheus.io/download/</a></p><p>解压并且移动到 &#x2F;opt&#x2F; 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# tar zxvf prometheus-2.45.0.linux-amd64.tar.gz</span><br><span class="line">[root@node1 ~]# mv prometheus-2.45.0.linux-amd64 /opt/prometheus/</span><br><span class="line">[root@node1 ~]# cd /opt/prometheus/</span><br></pre></td></tr></table></figure><h5 id="2、将-prometheus-配置为系统服务进行管理"><a href="#2、将-prometheus-配置为系统服务进行管理" class="headerlink" title="2、将 prometheus 配置为系统服务进行管理"></a>2、将 prometheus 配置为系统服务进行管理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/prometheus.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=prometheus</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/prometheus/prometheus --config.file=/opt/prometheus/prometheus.yml --storage.tsdb.path=/opt/prometheus/data/ --web.enable-lifecycle</span><br><span class="line">ExecReload=/bin/kill -HUP \$MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h5 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start prometheus</span><br><span class="line">systemctl enable prometheus</span><br></pre></td></tr></table></figure><p>出现关键信息<code>Server is ready to receive web requests.</code> 则启动成功，此时可以通过 <code>http://&lt;IP&gt;:9090</code> 访问 Prometheus 的 UI 界面</p><p><img src="/../images/ui_2.png" alt="image"></p><h5 id="4、配置-prometheus-数据源"><a href="#4、配置-prometheus-数据源" class="headerlink" title="4、配置 prometheus 数据源"></a>4、配置 prometheus 数据源</h5><p>为了让 Prometheus Server 能够从 Ceph Exporter 获取到监控数据，需要修改 Prometheus 配置文件。编辑 prometheus.yml 并在 scrape_configs 节点下添加以下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# vim /opt/prometheus/prometheus.yml</span><br><span class="line">...</span><br><span class="line">  - job_name: &quot;Ceph&quot;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;&lt;IP&gt;:9283&quot;]</span><br></pre></td></tr></table></figure><p>重新加载 <code>systemctl reload prometheus</code>,再次访问 <code>http://&lt;IP&gt;:9090</code>，选择<code>Status -&gt; Targets</code>，此时可以成功获取到 prometheus 数据源</p><p><img src="/../images/ui_3.png" alt="image"></p><h4 id="三、安装-grafana"><a href="#三、安装-grafana" class="headerlink" title="三、安装 grafana"></a>三、安装 grafana</h4><h5 id="1、二进制安装-1"><a href="#1、二进制安装-1" class="headerlink" title="1、二进制安装"></a>1、二进制安装</h5><p>下载地址：<a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# tar zxvf grafana-enterprise-8.0.5.linux-amd64.tar.gz</span><br><span class="line">[root@node1 ~]# mv grafana-8.0.5/ /opt/grafana/</span><br><span class="line">[root@node1 ~]# cd /opt/grafana/</span><br></pre></td></tr></table></figure><h4 id="2、将-grafana-配置为系统服务进行管理"><a href="#2、将-grafana-配置为系统服务进行管理" class="headerlink" title="2、将 grafana 配置为系统服务进行管理"></a>2、将 grafana 配置为系统服务进行管理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/grafana.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=grafana</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/opt/grafana/bin/grafana-server -homepath=/opt/grafana</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h5 id="3、启动-grafana-服务"><a href="#3、启动-grafana-服务" class="headerlink" title="3、启动 grafana 服务"></a>3、启动 grafana 服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start grafana</span><br><span class="line">systemctl enable grafana</span><br></pre></td></tr></table></figure><p>启动成功后可通过<code>http://&lt;IP&gt;:3000</code> 进入到 Grafana UI，默认情况下使用账户 admin&#x2F;admin 进行登录（首次登录会要求修改默认密码）。点击 “Add your first data source” 添加数据源</p><p><img src="/../images/ui_4.png" alt="image"></p><p>选择 “Prometheus”，点击右侧的 “Select”</p><p><img src="/../images/ui_5.png" alt="image"></p><p>“URL” 填写 Prometheus 的访问地址，滑到最下方点击 “Save &amp; test” 完成添加，配置正确的情况下会提示 “Data source is working” 的信息。</p><p>完成数据源的添加之后就可以在 Grafana 中创建可视化 Dashboard 了，选择左侧 <code>Dashboards -&gt; Manage</code>，点击 <code>Import</code>,输入 Dashboard 模板编号 2842，点击 <code>Load</code>,给 Dashboard 配置个名称，选择数据源为 <code>Prometheus</code>，最后点击 <code>Import</code></p><p><img src="/../images/ui_6.png" alt="image"></p><h4 id="部署中遇到的几个小问题："><a href="#部署中遇到的几个小问题：" class="headerlink" title="部署中遇到的几个小问题："></a>部署中遇到的几个小问题：</h4><p>1、由于服务器是局域网，时间服务器设置问题，导致 prometheus 对接数据源的时候会有警告<code>Warning: Error fetching server time: Detected 229.88299989700317 seconds time difference between your browser and the server. Prometheus relies on accurate time and time drift might cause unexpected query results.</code></p><p>先选择了笨办法手动改一下时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2023-06-28 11:41:00&quot;</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><p>2、添加 dashboard 模板时，输入模板编号提示<code>Bad Gateway</code>,此时可以去<a href="https://grafana.com/grafana/dashboards/">grafana dashboards官网</a>自行下载json文件然后<code>Upload JSON file</code><br><img src="/../images/ui_7.png" alt="image"></p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>文章主要参考自 <a href="https://www.koenli.com/af5b9d4e.html">使用 Prometheus+Grafana 监控 Ceph</a>，在此基础上根据自身环境所撰写，如有侵权请联系删除！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络流量问题排查-UDP丢包</title>
      <link href="/2024/05/22/Linux%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-UDP%E4%B8%A2%E5%8C%85/"/>
      <url>/2024/05/22/Linux%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-UDP%E4%B8%A2%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><em>一直以来对Linux网络这部分了解比较少，解决问题总是没有条理</em></p><p><strong>问题：</strong>遇到一个<strong>UDP丢包</strong>的问题：在测试中，一台VM虚拟机，CPU利用率55%左右，内存利用率7%左右，网卡流量也远没到限制的时候出现了丢包情况**</p><p><strong>验证：</strong><code>netstat -su|grep &quot;packet receive errors&quot;|awk &#39;&#123;print $1&#125;&#39;</code>  ，每30s查看一次，计算这次和上次之间的数值差值发现存在UDP丢包现象。</p><p>首先要看问题出现在哪儿，网络流量的路径是怎样的？</p><blockquote><p>1、网络流量通过有线&#x2F;无线发送到网卡<br>2、网卡驱动读取报文放到ring buffer（此时调用DMA，不经过CPU）<br>3、内核从ring buffer中读取报文进行处理，执行IP层，TCP&#x2F;UDP层逻辑<br>4、把报文发到用户态的socket buffer中，应用程序读取socket buffer并进行处理</p></blockquote><p>可能出现问题的地方：1、网卡处理时丢包   2、内核处理时丢包   3、应用程序处理时</p><blockquote><p>1、网卡阶段：</p></blockquote><p>两种方法：</p><p>(1).  <code>ifconfig</code> 查看 <strong>RX errors dropped</strong></p><p>(2).  <code>ethtool -S eth0 |egrep &quot;err|drop&quot;</code></p><p>如果存在丢包，可以查看网卡的ring buffer size是否设置太小达到瓶颈，使用<code>ethtool -g eth0</code>查看最大值和当前值，使用<code>ethtool -G eth0 rx 1024</code>进行修改</p><p>如果网卡方面没问题，那么尝试内核方面查看</p><blockquote><p>2、内核阶段</p></blockquote><p>linux 系统在接收报文之后，会把报文保存到缓存区中。因为缓存区的大小是有限的，如果出现 UDP 报文过大(超过缓存区大小或者 MTU 大小)、接收到报文的速率太快，都可能导致 linux 因为缓存满而直接丢包的情况。</p><p>使用<code>sysctl -a |grep net.core</code>查看相关参数设置</p><p>重点看这几个参数：</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_max</strong>：允许设置的 receive buffer 最大值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_default</strong>：默认使用的 receive buffer 值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_max</strong>：允许设置的 send buffer 最大值</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_dafault</strong>：默认使用的 send buffer 最大值</p><p>但是这些初始值并不是为了应对大流量的 UDP 报文，如果应用程序接收和发送 UDP 报文非常多，把这个值调大。</p><p>如果发现某些参数设置不合理需要修改的话：</p><p><strong>方法一</strong>：使用 sysctl 命令让它立即生效</p><p>接收最大值设置 sysctl -w net.core.rmem_max&#x3D;56214400 # 设置为 50M</p><p>接收默认值设置 sysctl -w net.core.rmem_default&#x3D;26214400 # 设置为 25M</p><p>发送最大值 sysctl -w net.core.wmem_max&#x3D;26214400 # 设置为 25M</p><p>发送默认值 sysctl -w net.core.wmem_default&#x3D;26214400 # 设置为 25M</p><p><strong>方法二</strong>：修改对应路径文件的参数或者修改 &#x2F;etc&#x2F;sysctl.conf 中对应的参数在下次启动时让参数保持生效（sysctl -p  生效）</p><blockquote><p>3、应用阶段</p></blockquote><p>系统的 UDP buffer size，调节的 sysctl 参数只是系统允许的最大值，每个应用程序在创建 socket 时需要设置自己 socket buffer size 的值。linux 系统会把接受到的报文放到 socket 的 buffer 中，应用程序从 buffer 中不断地读取报文。</p><p>另外一个因素是应用读取 buffer 中报文的速度，对于应用程序来说，处理报文应该采取异步的方式。</p><p>其他可能原因：</p><p>检查防火墙状态 <code>systemctl status firewalld</code>，或者 <code>iptables</code> 阻断了部分流量？</p><p>要处理的实际业务中，每一个连接会占用一个句柄，测试有反馈有 <em>“Too many open files”</em> 的错误。这可能导致数据丢失而没有正确执行实际业务。</p><p>陆续学习和更新</p><p><a href="https://blog.csdn.net/weixin_40754332/article/details/106924810">参考链接：数据传输过程中丢包分析处理</a></p><p>此外补充下小工具的使用</p><ul><li>netstat   主要是用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字。</li></ul><p><strong>-a</strong>      显示所有连接</p><p><strong>-t</strong>      TCP连接</p><p><strong>-u</strong>      UDP连接</p><p><strong>-l</strong>       列出所有处于监听状态的 Sockets</p><p><strong>-s</strong>      显示所有端口的统计信息，可配合-u&#x2F;-t使用</p><p><strong>Recv-Q</strong> 表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走</p><p><strong>send-Q</strong> 表示本地待发送的数据</p><p>这两个值通常应该为0，如果不为0可能是有问题的。packets在两个队列里都不应该有堆积状态。可接受短暂的非0情况。</p><p><a href="https://blog.csdn.net/wangquan1992/article/details/109508822">参考链接：netstat 命令详解及实现原理</a></p><ul><li>ethtool</li></ul><p><strong>ethtool eth0</strong>       显示网卡状态等信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ohh</title>
      <link href="/2024/05/22/ohh/"/>
      <url>/2024/05/22/ohh/</url>
      
        <content type="html"><![CDATA[<p>重新开始吧~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
